---
title: '01 - TreehopperFitness: Quality control'
author: "Micah Fletcher"
date: '`r Sys.Date()`'
output: 
  rmdformats::robobook:
  fig_width: 9
toc_depth: 3
---
  
```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.width = 8, fig.height = 6) 

library(kableExtra)   ## Needed if rendering tables
```
  
```{=html}
<style type="text/css">
  .book .book-body .page-inner {
    max-width: 1600px;
    margin-left: auto;
    margin-right: auto;
  }
details > summary {
  display: list-item;
}
</style>
```

# Data input, qc and pre-processessing for 2019 Publilia field data
```{r}
library(here)
library(tidyverse)
library(readxl)
library(lubridate)
library(stringr)

theme_set(theme_bw())
```

## 0 - Raw Data Input
Read in the data from `data_in_progress/Watershed_field_data_2019_ALL_local.xlsx`
```{r, warning = FALSE}
col_types = c("date", rep("text",8), "date", rep("text", 12))
in_filename <- here("data/Watershed_field_data_2019_ALL_local.xlsx")
in_data <- rbind(read_xlsx(in_filename, sheet = "A", col_types = col_types),
  read_xlsx(in_filename, sheet = "B", col_types = col_types),
  read_xlsx(in_filename, sheet = "C", col_types = col_types),
  read_xlsx(in_filename, sheet = "D", col_types = col_types),
  read_xlsx(in_filename, sheet = "E", col_types = col_types),
  read_xlsx(in_filename, sheet = "F", col_types = col_types),
  read_xlsx(in_filename, sheet = "G", col_types = col_types),
  read_xlsx(in_filename, sheet = "H", col_types = col_types)) %>%
  mutate(Date = as_date(Date),
         Time = hm(Time)) %>% 
  group_by(row_number()) %>% 
  mutate(Leaf = ifelse(!is.na(Female_ID) & is.na(Leaf), 
                       "S",
                       Leaf),
         Female_ID = ifelse(Female_ID %in% c("Uf", "Um", "M", "U") , # append plant and leaf to ID if female id is "unknown"
                            paste0(c(Female_ID, "_", as.character(Plant), "_", as.character(Leaf)), collapse = ""),
                            Female_ID)) %>%
  ungroup()
```

# 1 - Manually check and revise female IDs reproducibly

Create `Female_locations_on_dates` table to use for to manually check for obvious mismatched female IDs and typos in plant id or leaf id etc.

Then manually log these changes into `{dorm letter} Female_ID revisions` sheet then import these and revise the female IDs in the input data without editing the original data file.

Note that changes to things like plant id and leaf id had to be manually edited in the original data file. These are documented in the "Revisions" column in each sheet for each dorm in `Watershed_field_data_2019_ALL_local.xlsx`

## 1.1 - Flag duplicate female ID entries

Flag cases where the same female ID is used on the same day in the same dorm to aid in manual checking.

Display false negative and false positive duplicates in `Dup?` column (used in excel for field data entry).

```{r}
in_data_dupStatus <- in_data %>%
  group_by(Date, Dorm, Female_ID) %>%
    mutate(n_female_dupes = ifelse(!is.na(Female_ID) & !(Female_ID %in% c("E", "E?", "0", NA)),
                                   n(),
                                   NA),
           female_dup_order = ifelse(!is.na(Female_ID) & !(Female_ID %in% c("E", "E?", "0", NA)),
                                     row_number(),
                                     NA)) %>%
  ungroup() %>%
  mutate(dup_status = ifelse(!is.na(n_female_dupes) & !(Female_ID %in% c("E", "E?", "0", "N", NA)),
                             ifelse(n_female_dupes == 1 & !is.na(as.numeric(`Dup?`)),
                                    "Fpos", # copy-paste error or "?" ambiguity in Excel
                                    ifelse(n_female_dupes > 1 & !is.na(as.numeric(`Dup?`)),
                                           "Tpos", 
                                           ifelse(n_female_dupes > 1 & is.na(as.numeric(`Dup?`)),
                                                  "Fneg", # copy-paste error
                                                  ifelse(n_female_dupes == 1 & is.na(as.numeric(`Dup?`)),
                                                         "Tneg",
                                                         "Something went wrong!")))),
                             NA),
         Fem_IDn = ifelse(!is.na(n_female_dupes) & !(Female_ID %in% c("E", "E?", "0", "N", NA)),
                               ifelse(n_female_dupes == 1,
                                      Female_ID,
                                      paste0(Female_ID, "_d", female_dup_order)),
                               NA))

in_data_dupStatus %>%
  count(dup_status)

in_data_dupStatus %>% filter(dup_status == "Fpos") %>% distinct(Female_ID) %>% print(n=Inf)
in_data_dupStatus %>% filter(dup_status == "Tpos") %>% distinct(Female_ID) %>% print(n=Inf)
in_data_dupStatus %>% filter(dup_status == "Fneg") %>% distinct(Female_ID) %>% print(n=Inf)
in_data_dupStatus %>% filter(dup_status == "Tneg") %>% distinct(Female_ID) %>% print(n=Inf)
in_data_dupStatus %>% filter(dup_status == "Something went wrong!") %>% distinct(Female_ID) %>% print(n=Inf)
```

## 1.2 - Create `Female_locations_on_dates_dupStatus` table for manual checking.
Create female locations on dates table for manual checking.
```{r}
female_roster_days_dupStatus <- in_data_dupStatus %>%
  group_by(Date, Dorm) %>%
    distinct(Fem_IDn, .keep_all = TRUE) %>%
  ungroup() %>%
  select(Date, Dorm, Fem_IDn, Female_ID, Plant, Leaf, Eggs) %>%
  filter(!is.na(Fem_IDn), !grepl("M", Female_ID, ignore.case = TRUE))

female_roster_dupStatus <- female_roster_days_dupStatus %>%
  group_by(Dorm, Fem_IDn) %>%
    distinct(Fem_IDn) %>%
  ungroup()

# what days are each female observed on?
Female_locations_on_dates_dupStatus <- female_roster_days_dupStatus %>%
  group_by(row_number()) %>%
    mutate(location = paste0(c(Dorm, Plant, "_", Leaf), collapse = ""),
           Dorm_Fem_IDn = paste0(c(Dorm, "_", Fem_IDn), collapse = "")) %>%
  ungroup() %>%
  select(Dorm_Fem_IDn, location, Date) %>%
  spread(Date, location)

Days_observed_dupStatus <- female_roster_days_dupStatus %>% 
  group_by(Dorm, Fem_IDn) %>%
    summarize(Days_observed = n()) %>%
  ungroup() %>%
  arrange(Dorm, Days_observed)

# used 20200319 version
# write_csv(Days_observed_dupStatus, here("data/manual_check/Days_observed_dupStatus.csv"))
```

## 1.3 - Revise Female_ID using `Female_ID revisions dupStatus` sheet

```{r}
# Read in revisions table
Female_ID_revisions <- read_xlsx(in_filename, sheet = "Female_ID revisions dupStatus", col_types = c("date", "text", "text", "text","text", "text", "text", "text"), na = c("", "NA")) %>%
  mutate(Date = as_date(Date),
         Female_ID_revision_notes = Notes) %>%
  select(-Notes) %>%
  mutate(Date = `year<-`(Date, 2019)) # excel's fuckery with dates means any revisions I did in 2020 in the format m/d were interpretted as 2020-%m-%d

# Check number of duplicate rows in revisions sheet (should be 0)
ID_revision_duplicates <- Female_ID_revisions %>%
  group_by(Date, Dorm, Plant, Leaf, `From ID`) %>%
    mutate(n_rows_FromID = n()) %>%
  ungroup() %>%
  group_by(Date, Dorm, Plant, Leaf, `To ID`) %>%
    mutate(n_rows_ToID = n()) %>%
  ungroup() %>%
  arrange(Dorm, Plant, Leaf, Date) %>%
  filter(n_rows_FromID > 1 | n_rows_ToID > 1)
print(paste("Number of duplicate rows in revisions sheet:", nrow(ID_revision_duplicates)))

# Implement revisions from revisions table
All_data_v1 <- in_data_dupStatus %>% 
  full_join(Female_ID_revisions, by = c("Date", "Dorm", "Plant", "Leaf", "Fem_IDn" = "From ID")) %>%
  select(-dup_status) %>%
  # check whether any revisions entries had typos in location or tried to add a female where there was none
  mutate(orphaned_revisions = ifelse(!is.na(`To ID`) & is.na(Female_ID) | `To ID` == "NA",
                TRUE,
                FALSE)) %>%
  # change Female_ID to revised ID unless there was originally no Female_ID
  mutate(Female_ID = ifelse(!orphaned_revisions & !is.na(`To ID`),
                            `To ID`,
                            # add new Female_ID where there was originally no Female_ID
                            ifelse(orphaned_revisions & !is.na(`NA To ID`),
                                   `NA To ID`,
                                   Fem_IDn))) %>%
  # create `location` value combining dorm, plant and leaf into a string
  group_by(row_number()) %>%
    mutate(location = ifelse(!is.na(Leaf),
                             paste0(c(Dorm, Plant, "_", Leaf), collapse = ""),
                             NA)) %>%
  ungroup() %>%
  select(-`NA To ID`)

print(paste("Number of new Female_IDs where original Female_ID was NA:", nrow(All_data_v1  %>%
  filter(orphaned_revisions))))

# Generate new roster so I can manually doublecheck that there are no more mismatched IDs
female_roster_days_v1 <- All_data_v1 %>%
  group_by(Date, Dorm) %>%
    distinct(Female_ID, .keep_all = TRUE) %>%
  ungroup() %>%
  select(Date, Dorm, Female_ID, Plant, Leaf, Eggs) %>%
  filter(!is.na(Female_ID), !(Female_ID %in% c("E", "E?", "N", "0")), !grepl("M", Female_ID, ignore.case = TRUE))

female_roster_v1 <- female_roster_days_v1 %>%
  group_by(Dorm, Female_ID) %>%
    distinct(Female_ID) %>%
  ungroup()

data_revised_Female_locations_on_dates_v1 <- female_roster_days_v1 %>%
  group_by(row_number()) %>%
    mutate(location = ifelse(!is.na(Leaf),
                             paste0(c(Dorm, Plant, "_", Leaf), collapse = ""),
                             NA),
           Female_ID = paste0(c(Dorm, "_", Female_ID), collapse = "")) %>%
  ungroup() %>%
  select(Female_ID, location, Date) %>%
  spread(Date, location)

print("Number of unique female IDs were in original dataset vs. manually revised dataset:")
num_females_All_data <- female_roster_dupStatus %>% nrow()
num_females_All_data_revised <- female_roster_v1 %>% nrow()
print(paste("num_females_All_data:", num_females_All_data))
print(paste("num_females_All_data_revised:", num_females_All_data_revised))
```

### Plot the number of females over time.
```{r}
Num_females_eggs_v1 <- female_roster_days_v1 %>% # Note that this is not an accurate measure of the number of eggs since there are duplicate entries for the same leaf if more than one female per leaf
  group_by(Date, Dorm) %>%
    summarize(Num_females = sum(!is.na(Female_ID)), num_eggs = sum(!is.na(Eggs))) %>%
  ungroup()

# failed to visit all dorms on these days so they would uneven sampling
omit_days_ABCE = as_date(c("2019-06-02", "2019-06-03", "2019-06-05"))

Num_females_ABCE_v1 <- Num_females_eggs_v1 %>%
  filter(Dorm %in% c("A", "B", "C", "E")) %>%
  group_by(Date) %>%
  summarize(Num_females = sum(Num_females)) %>%
  ungroup() %>%
  filter(!(Date %in% omit_days_ABCE)) %>%
  mutate(year = "2019")

ggplot(data = Num_females_eggs_v1) +
  geom_line(aes(x = Date, y = Num_females, color = Dorm), size = 2)

ggplot(data = Num_females_ABCE_v1, aes(x = Date, y = Num_females)) +
  geom_line() +
  scale_y_continuous(limits = c(0,250))
```

# 2 - Manually check and revise egg initiation and hatching times reproducibly

*Note: This section saves many `.csv` files with tables to aid manual checks. In each case, the contents of these files were copied into the `data/Watershed_field_data_2019_ALL_local.xlsx` spreadsheet as new sheet at the time of initial analysis, revised manually as needed and subsequently read back in to this analysis script and used to revise the data object in the R environment. Every effort was made to keep the original field-collected dataseets unchanged in favor of programmatically revising the loading R object. In a few cases where this was not possible, the original spreadsheet was edited (with a note in the `Revisions` column). As such, newly generated check tables using this script may differ from the originals documented in `data/Watershed_field_data_2019_ALL_local.xlsx`, which preserve the original state of the data.*

## 2.1 - Flag cases where egg status is missing or inconsistent across multiple entries
(e.g. multiple females on same eggs, but only the first row was manually entered in the field)

I'll be redoing the same check many times so here's a function:
```{r}
egg_conflict_check <- function(dataset){
  egg_status <- dataset %>%
    group_by(row_number()) %>%
    filter(!Leaf %in% c("S","A"), !substring(Leaf, nchar(Leaf)) == "A") %>%
  group_by(Date, location) %>%
    distinct(Eggs, .keep_all = TRUE) %>%
    # mult entries for location/date but some are missing egg data
    mutate(eggs_need_filling = n() > 1) %>%
    # unique text entries for location/date
    mutate(num_unique_eggs = sum(!is.na(Eggs))) %>%
    # flag cases where more than one non-NA value unique values for Eggs
    mutate(egg_text_conflict = num_unique_eggs > 1) %>%  
    # flag cases where Egg status is ambiguous
    mutate(egg_status_missing = num_unique_eggs != 0 & Eggs %in% c("E?", "***")) %>% 
  ungroup() %>%
  select(Date, location, Eggs_status = Eggs, eggs_need_filling, egg_text_conflict, egg_status_missing, num_unique_eggs)
  return(egg_status)
}
```

```{r}
egg_status_v1_tmp <- egg_conflict_check(All_data_v1) %>%
  select(Date, location, Eggs_status, eggs_need_filling, egg_text_conflict, 
         egg_status_missing, num_unique_eggs)

# Flag any egg text conflicts or missing data that needs filling
egg_status_v1 <- egg_conflict_check(All_data_v1)

# Make dataframe to take missing values from
egg_fill_source <- egg_status_v1 %>%
  # keep only the Eggs values to fill missing data with for each location-time
  filter(eggs_need_filling, !egg_text_conflict, !is.na(Eggs_status)) %>%
  select(Date, location, Eggs_status, fill_from_src = eggs_need_filling)

# Join original dataset with new values such that missing values will be filled
# (but manually check that Eggs_filled is what you expect before replacing Eggs)
All_data_v2 <- All_data_v1 %>%
  left_join(egg_fill_source, by=c("Date", "location")) %>%
  mutate(Eggs_filled = ifelse(is.na(fill_from_src),
                              Eggs,
                              Eggs_status))
  
# Manually check that Eggs_filled is what you expect before replacing Eggs
All_data_v2 <- All_data_v2 %>% mutate(Eggs = Eggs_filled) %>% select(-Eggs_filled, -Eggs_status)
```

## 2.2 - Create tables to use for manually checking and revising egg status text conflict or missing data
```{r}
# Create table for entries text conflict that need to be resolved
egg_text_conflict_data_v1 <- All_data_v2 %>% # egg_text_conflict: 39 on 2019/09/24
  left_join(egg_status_v1, by = c("Date", "location", "Eggs" = "Eggs_status")) %>%
  filter(egg_text_conflict) %>%
  select(Date, Dorm, Plant, Leaf, Eggs)
# write_csv(egg_text_conflict_data_v1, here("data/manual_check/egg_text_conflict_data.csv"))

# Create table for entries with missing data that need to be resolved
egg_status_missing_data_v1 <- All_data_v2 %>% # egg_status_missing: 219 on 2019/09/24
  left_join(egg_status_v1, by = c("Date", "location", "Eggs" = "Eggs_status")) %>%
  filter(egg_status_missing, !grepl('NA|M', Female_ID)) %>%
  select(Date, Dorm, Plant, Leaf, Eggs)
# write_csv(egg_status_missing_data_v1, here("data/manual_check/egg_status_missing_data.csv"))

print("Conflicts and missing data before implementing manual revisions:")
print(paste("egg_text_conflict_data:", nrow(egg_text_conflict_data_v1)))
print(paste("egg_status_missing_data:", nrow(egg_status_missing_data_v1)))
```

## 2.3 - Import and implement `egg status missing data` revisions
`import "egg_stats_missing_data revision" > implement revisions > `
   `standardize the L6A8 vs. L6a8 vs. 6a8 format > get summary of start of egg number over time > `
   `define a (soft?) cuttoff for settling *** ambiguities > implement cuttoff > proceed to checking clutch lifetime`
   
```{r}
# Read in manual revisons table
egg_status_revisions <- read_xlsx(in_filename, sheet = "egg_stats_missing_data revision", col_types = c("date", "text", "text", "text","text", "text", "text", "date")) %>%
  mutate(Date = as_date(Date)) %>%
  select(-`Date revised`)

# Check revisions table for duplicate (i.e. overwriting) entries
egg_stats_revision_duplicates <- egg_status_revisions %>%
  group_by(Date, Dorm, Plant, Leaf) %>%
    mutate(n_rows = n()) %>%
  ungroup() %>%
  arrange(Dorm, Plant, Leaf, Date) %>%
  filter(n_rows > 1)
print(paste("Number of duplicate rows in revisions sheet:", nrow(egg_stats_revision_duplicates)))

# Implement revisions from revisions table
All_data_v3 <- All_data_v2 %>% 
  rename(Eggs_v2 = Eggs) %>%
  full_join(egg_status_revisions, by = c("Date", "Dorm", "Plant", "Leaf")) %>%
  rename(Eggs_v2_xls = Eggs, Notes = Notes.x) %>%
  # need to check whether locations are properly assigned to each revision
  mutate(Eggs_v3 = ifelse(Eggs_revisions != "IGNORE" & !is.na(Eggs_revisions),
                            Eggs_revisions,
                            Eggs_v2)) %>%
  select(-Num_adults, -Description, -`Paired with`, -Time, -Notes.y, -`Dup?`, -`row_number()`,
         -fill_from_src, -Eggs_v2_xls, -Eggs_revisions, -orphaned_revisions, -Fem_IDn,
         -`To ID`, -n_female_dupes, -female_dup_order, -Female_ID_revision_notes, -Eggs_v2) %>%
  select(Date, Dorm, Plant, Leaf, location, Female_ID, Eggs = Eggs_v3,
         N1, N2, N5, New_eA, Old_eA, nymph_origin, everything())

# Check whether revisions implementation worked by rerunning inconsistency checks
# Flag any egg text conflicts or missing data that needs filling
egg_status_v2 <- egg_conflict_check(All_data_v3)

# Conflicts and missing data after implementing manual revisions
egg_text_conflict_data_v2 <- All_data_v3 %>%
  group_by(row_number()) %>%
  mutate(Female_ID = paste0(c(Dorm, "_", Female_ID), collapse = "")) %>%
  ungroup() %>%
  left_join(egg_status_v2, by = c("Date", "location", "Eggs" = "Eggs_status")) %>%
  filter(egg_text_conflict) %>%
  select(Date, Dorm, Plant, Leaf, Eggs)

egg_status_missing_data_v2 <- All_data_v3 %>%
  group_by(row_number()) %>%
  mutate(Female_ID = paste0(c(Dorm, "_", Female_ID), collapse = "")) %>%
  ungroup() %>%
  left_join(egg_status_v2, by = c("Date", "location", "Eggs" = "Eggs_status")) %>%
  filter(egg_status_missing, !grepl('NA|M', Female_ID)) %>%
  select(Date, Dorm, Plant, Leaf, Eggs) #%>% print(n=Inf)

print("Conflicts and missing data after implementing manual revisions:")
print(paste("egg_text_conflict_data_eggs_revised:", nrow(egg_text_conflict_data_v2)))
print(paste("egg_status_missing_data_eggs_revised:", nrow(egg_status_missing_data_v2)))

# 20200326 version was used
# write_csv(egg_status_missing_data_eggs_revised, here("data/manual_check/egg_status_missing_data_eggs_revised.csv"))
```

## 2.4 - Import and implement `egg measures` revisions
```{r}
# Read in manual revisons table
egg_measures_revisions <- read_xlsx(in_filename, sheet = "egg_measures_revisions", col_types = c("text", "date", "text", "text","text"), na = c("", "NA")) %>%
  mutate(Date = as_date(Date)) %>%
  select(-Notes)

# Check revisions table for mismatched entries
egg_measures_revisions_mismatched <- All_data_v3 %>%
  full_join(egg_measures_revisions, by = c("location", "Date")) %>%
  semi_join(egg_measures_revisions, by = c("location", "Date")) %>%
  filter(is.na(Eggs) | Eggs != `Eggs from`) %>%
  select(Date, Dorm, Plant, Leaf, location, Female_ID, Eggs, `Eggs from`, `Eggs to`)
print(paste("egg_measures_revisions_mismatched: ", nrow(egg_measures_revisions_mismatched)))

# Implement revisions from revisions table
All_data_v4 <- All_data_v3 %>%
  full_join(egg_measures_revisions, by = c("location", "Date")) %>%
  mutate(Eggs_match_revision = ifelse(!is.na(Eggs) & !is.na(`Eggs from`) & Eggs == `Eggs from`,
                       TRUE,
                       FALSE),
         Eggs_v5 = ifelse(Eggs_match_revision,
                       `Eggs to`,
                       Eggs)) %>%
  select(-Eggs, -`Eggs from`, -`Eggs to`, -Eggs_match_revision) %>%
  select(Date, Dorm, Plant, Leaf, location, Female_ID, Eggs = Eggs_v5,
         N1, N2, N5, New_eA, Old_eA, nymph_origin, everything())

# Check whether revisions implementation worked by rerunning inconsistency checks
egg_status_v3 <- egg_conflict_check(All_data_v4)

egg_text_conflict_data_v3 <- All_data_v4 %>%
  group_by(row_number()) %>%
  mutate(Female_ID = paste0(c(Dorm, "_", Female_ID), collapse = "")) %>%
  ungroup() %>%
  left_join(egg_status_v3, by = c("Date", "location", "Eggs" = "Eggs_status")) %>%
  filter(egg_text_conflict) %>%
  select(Date, Dorm, Plant, Leaf, Eggs)

egg_status_missing_data_v3 <- All_data_v4 %>%
  group_by(row_number()) %>%
  mutate(Female_ID = paste0(c(Dorm, "_", Female_ID), collapse = "")) %>%
  ungroup() %>%
  left_join(egg_status_v3, by = c("Date", "location", "Eggs" = "Eggs_status")) %>%
  filter(egg_status_missing, !grepl('NA|M', Female_ID)) %>%
  select(Date, Dorm, Plant, Leaf, Eggs) #%>% print(n=Inf)

print(paste("egg_text_conflict_data_eggs_revised:", nrow(egg_text_conflict_data_v3)))
print(paste("egg_status_missing_data_eggs_revised:", nrow(egg_status_missing_data_v3)))

# 20200326 version was used
# write_csv(egg_status_missing_data_eggs_revised, here("data/manual_check/egg_status_missing_data_eggs_revised.csv")
```

### Omit inconsistent egg measures from 7/4
Luke used a much more conservative metric for number of eggs on 7/4; convert these measures to "E" for Dorms A, E, F
```{r}
egg_status_v4 <- egg_status_v3 %>%
  mutate(Eggs_status = ifelse(Date == as.Date("2019-07-04") & grepl("^(A|E|F)", location) & grepl("[0-9]e ", Eggs_status),
                              "E",
                              Eggs_status))
```

## 2.5 - Create `revised_clutch_status_on_dates` table for second round of manual checking
Create female locations on dates table for manual checking (as for Female IDs) and get a rough count of the number of clutches in this first round.
```{r}
# Only include clutches, not leaves that never had eggs and not leaves that only had nymphs
any_eggs_not_just_nymphs <- egg_status_v4 %>%
  select(location, Clutch_status = Eggs_status, Date) %>%
  group_by(location) %>%
    summarize(any_eggs_or_nymphs = any(!is.na(Clutch_status)),
              any_eggs_not_just_nymphs = any(!is.na(Clutch_status) &
                                               !(Clutch_status %in% c("N","0")))) %>%
  ungroup() %>%
  filter(any_eggs_not_just_nymphs)


revised_clutch_status_on_dates <- egg_status_v4 %>%
  left_join(any_eggs_not_just_nymphs, by = c("location")) %>%
  filter(any_eggs_not_just_nymphs) %>%
  select(location, Clutch_status = Eggs_status, Date) %>%
  spread(key = Date, Clutch_status)

# 402 clutches in revised data as of 2019/09/25
print(paste(nrow(revised_clutch_status_on_dates), "clutches in revised data"))
```

## 2.6 - Define initiation dates (v1) to help with manual checks
First pass initiation dates, before filling nymphs in duplicate entries and manual checks
```{r}
## 1: define initiation date, hatch date (taking into account "not hatched" notes)
clutch_status_v1 <- egg_status_v4 %>%
  left_join(any_eggs_not_just_nymphs, by = c("location")) %>%
  filter(any_eggs_not_just_nymphs) %>%
  select(location, Clutch_status = Eggs_status, Date) %>%
  mutate(Egg_measures = ifelse(grepl("[1234567890]e", Clutch_status),
                                Clutch_status,
                               ifelse(!is.na(as.integer(Clutch_status)),
                                      Clutch_status,
                                      NA_character_)
                               )
         ) %>%
  separate(Egg_measures, into = c("egg_num", "egg_len"), sep = "e", remove = FALSE) %>%
  mutate(egg_num = as.integer(str_trim(egg_num)), 
         egg_len = as.integer(str_trim(egg_len))) #%>%
 # filter(!is.na(Egg_measures) & is.na(egg_len)) # check this if change anything upstream

# 369 clutches had defined initiation dates as of 2019/09/25
initiation_dates_v1 <- clutch_status_v1 %>%
  filter(!is.na(Egg_measures) & Egg_measures != "0" | str_trim(Clutch_status, side = "both") == "E") %>%
  group_by(location) %>%
    filter(row_number() == 1) %>%
  ungroup() %>%
  select(location, initiation_date = Date)

print(paste(nrow(initiation_dates_v1), "clutches have defined initiation dates"))

# 33 clutches didn't have an initiation date as of 2019/09/25 because they had no days where the eggs were measured
#clutch_status_v1 %>% anti_join(initiation_dates) %>% distinct(location)
#clutch_status_v1 %>% anti_join(initiation_dates) %>% arrange(location, Date) %>% print(n=Inf)

print(paste(nrow(clutch_status_v1 %>% anti_join(initiation_dates_v1) %>% distinct(location)), 
            "clutches didn't have an initiation date because they had no days where the eggs were measured"))

```

## 2.7 - Fix cases where nymph status is missing or inconsistent across multiple entries
Similar process as with egg status above, but generalizing for differen columns in tibble. 
Default is to group by date and location, but `perPlant`=TRUE allows to group by date and plant.
```{r}
text_conflict_check <- function(tibble, N, perPlant=FALSE){
  # N = N1, N2, N5, NOr, Ants_on_leaf, Ants_on_plant (perPlant=TRUE)
  require(dplyr)
  if(perPlant == FALSE) {
    # N = Eggs, N1, N2, N5, NOr, Ants_on_leaf
    N_status <- tibble %>%
      filter(!Leaf %in% c("S","A"), !substring(Leaf, nchar(Leaf)) == "A") %>%
      group_by(Date, location) %>%
      distinct((!!as.name(N)), .keep_all = TRUE) %>%
      # mult entries for location/date but some are missing nymph data
      mutate(N_need_filling = n() > 1) %>%
      # unique text entries for location/date
      mutate(num_unique_N = sum(!is.na(!!as.name(N)))) %>%
      # flag cases where more than one non-NA value unique values for nymph
      mutate(N_text_conflict = num_unique_N > 1) %>%
      # flag cases where nymph status is ambiguous
      mutate(N_status_missing = !is.na(!!as.name(N)) & 
               is.na(suppressWarnings(as.integer(!!as.name(N))))) %>% 
      ungroup() %>%
      select(Date, location, N, N_need_filling, N_text_conflict, N_status_missing, num_unique_N)
  } else {
    # N = Ants_on_plant (perPlant=TRUE)
    N_status <- tibble %>%
      group_by(Date, Dorm, Plant) %>%
      distinct((!!as.name(N)), .keep_all = TRUE) %>%
      mutate(N_need_filling = n() > 1) %>%
      mutate(num_unique_N = sum(!is.na(!!as.name(N)))) %>%
      mutate(N_text_conflict = num_unique_N > 1) %>%
      mutate(N_status_missing = !is.na(!!as.name(N)) & 
               is.na(suppressWarnings(as.integer(!!as.name(N))))) %>% 
      ungroup() %>%
      select(Date, Dorm, Plant, N, N_need_filling, N_text_conflict, N_status_missing, num_unique_N)
  }
  return(N_status)
}
```

```{r}
N1_status <- text_conflict_check(All_data_v4, N = "N1") %>%
  select(Date, location, N1, N1_need_filling = N_need_filling, 
         N1_text_conflict = N_text_conflict, N1_status_missing = N_status_missing)

print(paste("N1_need_filling: ", nrow(N1_status %>% filter(N1_need_filling))))
print(paste("N1_text_conflict: ", nrow(N1_status %>% filter(N1_text_conflict))))
print(paste("N1_status_missing: ", nrow(N1_status %>% filter(N1_status_missing))))

N2_status <- text_conflict_check(All_data_v4, N = "N2") %>%
  select(Date, location, N2, N2_need_filling = N_need_filling, 
         N2_text_conflict = N_text_conflict, N2_status_missing = N_status_missing)

print(paste("N2_need_filling: ", nrow(N2_status %>% filter(N2_need_filling))))
print(paste("N2_text_conflict: ", nrow(N2_status %>% filter(N2_text_conflict))))
print(paste("N2_status_missing: ", nrow(N2_status %>% filter(N2_status_missing))))

N5_status <- text_conflict_check(All_data_v4, N = "N5") %>%
  select(Date, location, N5, N5_need_filling = N_need_filling, 
         N5_text_conflict = N_text_conflict, N5_status_missing = N_status_missing)

print(paste("N5_need_filling: ", nrow(N5_status %>% filter(N5_need_filling))))
print(paste("N5_text_conflict: ", nrow(N5_status %>% filter(N5_text_conflict))))
print(paste("N5_status_missing: ", nrow(N5_status %>% filter(N5_status_missing))))

# Adding nymph origin to nymph status so that I can check for ambiguous nymph origins with clutch status and better filter problematic clutches for calculating hatch success and nymph survival
NOr_status <- text_conflict_check(All_data_v4, N = "nymph_origin") %>%
  # flag cases where nymph_origin status is ambiguous
  group_by(Date, location) %>%
  mutate(NOr_ambiguous = !is.na(nymph_origin) & 
           suppressWarnings(is.na(as.integer(nymph_origin)))) %>% 
  ungroup() %>%
  select(Date, location, nymph_origin, NOr_need_filling = N_need_filling, 
         NOr_text_conflict = N_text_conflict, NOr_ambiguous)

nymph_status <- N1_status %>% 
  left_join(N2_status) %>% 
  left_join(N5_status) %>% 
  left_join(NOr_status)

nymph_status_to_resolve <- nymph_status  %>% # should only include a handful of entries with "?" ambiguous entries for N1 or N2 (because did the revions by hand on 2019/09/26)
  group_by(row_number()) %>%
    filter(any(N1_need_filling, N1_text_conflict, N1_status_missing,
               N2_need_filling, N2_text_conflict, N2_status_missing,
               N5_need_filling, N5_text_conflict, N5_status_missing)) %>%
  ungroup()
# write_csv(nymph_status_to_resolve, here("data/manual_check/nymph_status_to_resolve.csv") ## manually added this to "nymph_status revisions" sheet in "Watershed_field_data_2019_ALL_local" and manually revised raw data 2019/09/26

print(paste("nymph_status_to_resolve: ", nrow(nymph_status_to_resolve)))

# checking number of ambiguous entries that need to be resolved
nymph_text_conflict_data <- All_data_v4 %>% # nymph_text_conflict: 10 on 2019/09/24; 0 on 2019/09/26
  left_join(N1_status, by = c("Date", "location", "N1")) %>%
  left_join(N2_status, by = c("Date", "location", "N2")) %>%
  left_join(N5_status, by = c("Date", "location", "N5")) %>%
  group_by(row_number()) %>% 
    filter(any(c(N1_text_conflict, N2_text_conflict, N5_text_conflict))) %>%
  ungroup() %>%
  select(Date, Dorm, Plant, Leaf, Female_ID, Eggs, N1, N2, N5, nymph_origin, Notes, N1_text_conflict, N2_text_conflict, N5_text_conflict)
# write_csv(egg_text_conflict_data, "egg_text_conflict_data.csv")

nymph_status_missing_data <- All_data_v4 %>% # nymph_status_missing: 17 on 2019/09/24; 5 on 2019/09/26 (all ok to ignore)
  left_join(N1_status, by = c("Date", "location", "N1")) %>%
  left_join(N2_status, by = c("Date", "location", "N2")) %>%
  left_join(N5_status, by = c("Date", "location", "N5")) %>%
  group_by(row_number()) %>% 
  filter(any(c(N1_status_missing, N2_status_missing, N5_status_missing))) %>%
  ungroup() %>%
  select(Date, Dorm, Plant, Leaf, Female_ID, Eggs, N1, N2, N5, nymph_origin, Notes, N1_status_missing, N2_status_missing, N5_status_missing)
# write_csv(egg_status_missing_data, "egg_status_missing_data.csv")

print("checking number of ambiguous nymph entries that need to be resolved:")
print(paste("nymph_text_conflict_data: ", nrow(nymph_text_conflict_data)))
print(paste("nymph_status_missing_data: ", nrow(nymph_status_missing_data)))

# clutch_status_v1 should have no duplicate entries for location and date, so I can safely left_join the nymph status information
print("clutch_status_v1 should have no duplicate entries for location and date, so I can safely left_join the nymph status information")
print(paste("instances with more than one entry per location and date for in clutch_status_v1: ",
            nrow(clutch_status_v1 %>% group_by(Date, location) %>% summarize(n = n()) %>% ungroup() %>% filter(n < 1))))
```

## 2.8 - Define hatch dates (v1) to help with manual checks
Define hatch date for this dataset:
First day that n1 appear unless "not hatched" in notes -> check manually
  - roughly: filter(!is.na(N1) & !grepl("not hatched", Notes))
```{r}
clutch_nymph_status_v1 <- clutch_status_v1 %>% 
  left_join(nymph_status, by = c("Date", "location")) %>%
  select(location, Date, Clutch_status, Egg_measures, egg_num, egg_len, N1, N2, N5, nymph_origin, NOr_ambiguous) %>%
  arrange(location, Date)

hatch_dates_v1 <- clutch_nymph_status_v1 %>%
  filter(!is.na(as.integer(N1)) & N1 != 0) %>% 
  # & notes that don't mention "not hatched yet" <- manually checked below with "check_hatch_date" and revised with "check_hatch_date_revisions"
  group_by(location) %>%
    filter(row_number() == 1) %>%
  ungroup() %>%
  select(location, hatch_date = Date)

print("Hatch_dates v1 (filled in nymphs but not yet incorporating 'not hatched' notes):")
print(paste("hatch_dates: ", nrow(hatch_dates_v1)))
```

## 2.9 - Manually check hatch dates using the "not hatched" notes from field using `check_hatch_date` sheet
Use the "not hatched" notes (from original field notes; typically b/c nymphs present but they are immigrants, not hatched from the focal clutch) to inform first pass of hatch date revisions
Again these changes were specified in the `check_hatch_date` sheet and are applied here without changing the original data file.
```{r}
# Create `check_hatch_date` sheet for checking "not hatched" notes and suggesting manual revisions
check_hatch_date <- All_data_v4  %>%
  filter(grepl("not", Notes, ignore.case = TRUE), grepl("hatch", Notes, ignore.case = TRUE)) %>%
  distinct(location)
# write_csv(check_hatch_date, "check_hatch_date_tmp.csv")
```

### Revise initiation dates and hatch dates (v2) based on `check_hatch_date` manual check
```{r}
# Revise initiation dates and hatch dates based on `check_hatch_date` manual check
check_hatch_date_revisions <- read_xlsx(in_filename, sheet = "check_hatch_date", col_types = c("text", "text", "date", "date", "text", "text", "text", "text")) %>%
  select(location, revised_hatch_date_date, revised_hatch_date_text) %>%
  mutate(revised_hatch_date_date = date(revised_hatch_date_date))

hatch_dates_v2 <- hatch_dates_v1 %>% 
  left_join(check_hatch_date_revisions, by="location") %>%
  mutate(hatch_date = if_else(!is.na(revised_hatch_date_date),
                              revised_hatch_date_date,
                              if_else(revised_hatch_date_text %in% c("never hatched", "no eggs"),
                                      as.Date(NA),
                                      hatch_date))) %>%
  select(location, hatch_date)

# Just checking that all of the clutches determined to have no eggs don't have initiation dates
# (this shouldn't do anything if so)
initiation_dates_v2 <- initiation_dates_v1 %>% 
  left_join(check_hatch_date_revisions, by="location") %>%
  mutate(initiation_date = if_else(!is.na(revised_hatch_date_text) & revised_hatch_date_text == "no eggs",
                            as.Date(NA),
                            initiation_date)) %>%
  select(location, initiation_date)

print("Hatch_dates (v2) after incorporating 'not hatched' notes:")
print(paste("hatch_dates_v2: ", nrow(hatch_dates_v2)))
print("Initiation_dates (v2) after manually checking:")
print(paste("initiation_dates_v2: ", nrow(initiation_dates_v2)))
```

## 2.10 - Manually check clutches with short initiation-hatch intervals
Changes were specified in the `short_unhatched_days_check` sheet and are applied here without changing the original data file.

Criteria used to manually flag unusually short init-hatch intervals:
- outlier starting egg number (suggests I'm missing first obs)
- spurious 0 entry for Eggs
- immigration of N1 from another leaf
- mother not accounted for on previous days

## 2.11 - Use `short_unhatched_days_check` sheet to revise initiation and hatch dates (v3)
*NOTE:* I just use these revisions to adjust the female guarding duration data, rather than revising the "All_data_revised_eggs_revised". *the All_data tibble is thus not a perfect source of nymph counts*

### Implement initiation date (v3) revisions
Where it was obvious that the initiation date was overlooked in the field (based on above criteria), I specified that an "E" be entered at that location on the suspected initiation date.
```{r}
# Use "short_unhatched_days_check" sheet to further revise hatch dates
short_unhatched_check_revisions <- read_xlsx(in_filename, sheet = "short_unhatched_days_check") %>%#, col_types = c("text", "text", "date", "date", "text", "text", "text", "text")) %>%
  select(location, Egg_revisions, Hatch_revised, Initiation_revised, Female_revision_ID, Female_revision_date, Omit_for_abandon_time)

short_unhatched_check_revisions_eggs <- short_unhatched_check_revisions %>%
  filter(grepl("no eggs|initiated|hatched",Egg_revisions) | Omit_for_abandon_time == "yes", !grepl("manually|fixed", Egg_revisions)) %>% print(n=Inf)

initiation_dates_v3 <- initiation_dates_v2 %>% 
  left_join(short_unhatched_check_revisions, by="location") %>%
  mutate(initiation_date_revised = if_else(grepl("no eggs|initiated|hatched",Egg_revisions) & !grepl("manually|fixed", Egg_revisions),
                                      if_else(Egg_revisions == "no eggs",
                                              as.Date(NA),
                                              if_else(!is.na(Initiation_revised),
                                                      as.Date(Initiation_revised),
                                                      initiation_date)
                                      ),
                                      initiation_date)) %>%
  filter(is.na(Omit_for_abandon_time)) %>%
  arrange(location) %>%
  select(location, initiation_date, initiation_date_revised) %>% # check that this worked before proceeding!
  select(location, initiation_date = initiation_date_revised)

print("Initiation_dates (v3) after manually checking unusually short unhatched days:")
print(paste("initiation_dates_v3: ", nrow(initiation_dates_v3)))
```

### Implement hatch date (v3) revisions
Where it was obvious that the hatch date (v2) was incorrect (e.g. immigration of N1), I specified a new hatch date (v3). *Note that only hatch date is thus revised, and not the nymph status in `All_data`.* _So if I need to have accurate nymph status on specific dates for downstream analysis, I would need to adjust this to add a "N" or some similar nymph placeholder for those location-dates._
```{r}
hatch_dates_v3 <- hatch_dates_v2 %>% 
  left_join(short_unhatched_check_revisions, by="location") %>%
  group_by(location) %>%
  mutate(hatch_date_revised = if_else(grepl("no eggs|initiated|hatched",Egg_revisions) & !grepl("manually|fixed", Egg_revisions),
                              if_else(Egg_revisions %in% c("never hatched", "no eggs"),
                                      as.Date(NA),
                                      if_else(!is.na(Hatch_revised),
                                              as.Date(Hatch_revised),
                                              hatch_date)
                                      ),
                              hatch_date)) %>%
  ungroup() %>%
  filter(is.na(Omit_for_abandon_time)) %>%
  select(location, hatch_date, hatch_date_revised) %>% # check that this worked before proceeding!
  select(location, hatch_date = hatch_date_revised)

print("Hatch_dates (v3) after manually checking unusually short unhatched days:")
print(paste("hatch_dates_v3: ", nrow(hatch_dates_v3)))
```

### Specify which clutches should be omitted from desertion date analyses
- If we likely missed first several days of clutch, unclear how early initiated, and unclear who was present at initiation.
- Or unclear whether eggs never hatched
```{r}
omit_for_abandon_time <- short_unhatched_check_revisions %>%
  filter(!is.na(Omit_for_abandon_time)) %>%
  select(location, Omit_for_abandon_time)
print(paste("Clutches with ambiguous init/hatch dates to omit from desertion date analysis: ", nrow(omit_for_abandon_time)))
```

## 2.10 - Use `short_unhatched_days_check` sheet to revise Female IDs
Add females to `All_data` where they were not originally observed based on evidence from short init-hatch interval.
When a female was guarding shortly after initiation but neither the eggs nor the mother was observed on the revised day of initiation, it was assumed that we overlookoed that location in the field on that day, so she was added accordingly. These revisions are tracked in the `short_unhatched_days_check` sheet.
```{r}
# Add females from short_unhatched_check_revisions to `All_data` tibble
short_unhatched_check_revisions_moms <- short_unhatched_check_revisions %>% 
  filter(!is.na(Female_revision_ID) & Female_revision_ID != "?") %>%
  separate_rows(Female_revision_date, sep = ",") %>%
  mutate(Female_revision_date = as.Date(str_trim(Female_revision_date, side = "both"))) %>%
  select(Date = Female_revision_date, location, Female_revision_ID) %>%
  separate(location, c("DormPlant", "Leaf"), "_", remove = FALSE) %>%
  mutate(Dorm = substr(DormPlant, 1,1),
         Plant = substring(DormPlant, 2)) %>%
  select(Date, location_revision = location, Dorm, Plant, Leaf, Female_revision_ID)
  

All_data_v5 <- All_data_v4 %>% 
  full_join(short_unhatched_check_revisions_moms, by = c("Date", "Dorm", "Plant", "Leaf")) %>%
  mutate(Female_ID = ifelse(!is.na(Female_revision_ID),
                            paste0(Dorm, "_", Female_revision_ID),
                            ifelse(!is.na(Female_ID),
                                   paste0(Dorm, "_", Female_ID),
                                   NA)),
         location = ifelse(is.na(location_revision),
                           location,
                           ifelse(is.na(location),
                                  location_revision,
                                  NA)),
         Eggs = ifelse(!is.na(Female_revision_ID),
                       "E",
                       Eggs)) %>%
  select(-Female_revision_ID, -location_revision)
```

## 2.11 Update clutch_status data using revised `All_data` table
```{r}
egg_status_v5 <- egg_conflict_check(All_data_v5) %>%
  select(Date, location, Eggs_status, eggs_need_filling, egg_text_conflict, egg_status_missing) %>%
  # Luke used a much more conservative metric for number of eggs on 7/4; convert these measures to "E" for Dorms A, E, F
  mutate(Eggs_status = ifelse(Date == as.Date("2019-07-04") & grepl("^(A|E|F)", location) & grepl("[0-9]e ", Eggs_status),"E",Eggs_status))

# Only include clutches, not leaves that never had eggs and not leaves that only had nymphs
any_eggs_not_just_nymphs_v2 <- egg_status_v5 %>%
  select(location, Clutch_status = Eggs_status, Date) %>%
  group_by(location) %>%
    summarize(any_eggs_or_nymphs = any(!is.na(Clutch_status)),
              any_eggs_not_just_nymphs = any(!is.na(Clutch_status) &
                                               !(Clutch_status %in% c("N","0")))) %>%
  ungroup() %>%
  filter(any_eggs_not_just_nymphs)

# define initiation date, hatch date
clutch_status_v2 <- egg_status_v4 %>%
  left_join(any_eggs_not_just_nymphs_v2, by = c("location")) %>%
  filter(any_eggs_not_just_nymphs) %>%
  select(location, Clutch_status = Eggs_status, Date) %>%
  mutate(Egg_measures = ifelse(grepl("[1234567890]e", Clutch_status),
                                Clutch_status,
                               ifelse(!is.na(as.integer(Clutch_status)),
                                      Clutch_status,
                                      NA_character_)
                               )
         ) %>%
  separate(Egg_measures, into = c("egg_num", "egg_len"), sep = "e", remove = FALSE) %>%
  mutate(egg_num = as.integer(str_trim(egg_num)), 
         egg_len = as.integer(str_trim(egg_len))) #%>%
 # filter(!is.na(Egg_measures) & is.na(egg_len)) # check this if change anything upstream

clutch_nymph_status_v2 <- clutch_status_v2 %>% 
  left_join(nymph_status, by = c("Date", "location")) %>%
  select(location, Date, Clutch_status, Egg_measures, egg_num, egg_len, N1, N2, N5, nymph_origin, nymph_origin, NOr_ambiguous) %>%
  arrange(location, Date)
```

# 3 - Revise ant data reproducibly
Revised ant data and updated All_data_v5 to All_data_v6
Note that the only changes from All_data_v5 to All_data_v6 were adding columns for ant data and all variables derived from All_data_v5 should be safe to left_join with All_data_v6

## 3.1 - Fill empty entries and resolve text conflicts
As for eggs and nymphs above
```{r}
## find plants where ants were not filled in for all duplicate leaf or plant entries
## for duplicate plant entries
plant_ants_flagged_v1 <- text_conflict_check(All_data_v5, N="Ants_on_plant", perPlant=TRUE) %>%
  select(Date, Dorm, Plant, Ants_on_plant, 
         plant_ants_need_filling = N_need_filling,
         plant_ants_text_conflict = N_text_conflict,
         num_unique_plant_ants = num_unique_N)

plant_ants_fill_source_v1 <- plant_ants_flagged_v1 %>%
  filter(plant_ants_need_filling, !plant_ants_text_conflict, !is.na(Ants_on_plant)) %>%
  select(Date, Dorm, Plant, Ants_on_plant_fill = Ants_on_plant, plant_ants_fill_from_src = plant_ants_need_filling)

All_data_v5_plant_ants_v1 <- All_data_v5 %>%
  left_join(plant_ants_fill_source_v1, by=c("Date", "Dorm", "Plant")) %>%
  mutate(Ants_on_plant_filled = ifelse(is.na(plant_ants_fill_from_src),
                              Ants_on_plant,
                              Ants_on_plant_fill))

# manually check that Ants_on_plant_filled is what you expect before replacing Ants_on_plant
All_data_v5_plant_ants_v1 <- All_data_v5_plant_ants_v1  %>% mutate(Ants_on_plant = Ants_on_plant_filled) %>% select(-Ants_on_plant_filled)

## for duplicate leaf entries
leaf_ants_flagged_v1 <- text_conflict_check(All_data_v5, N="Ants_on_leaf", perPlant=FALSE) %>%
  select(Date, location, Ants_on_leaf,
         leaf_ants_need_filling = N_need_filling,
         leaf_ants_text_conflict = N_text_conflict,
         num_unique_leaf_ants = num_unique_N)

leaf_ants_fill_source_v1 <- leaf_ants_flagged_v1 %>%
  filter(leaf_ants_need_filling, !leaf_ants_text_conflict, !is.na(Ants_on_leaf)) %>%
  select(Date, location, Ants_on_leaf_fill = Ants_on_leaf, leaf_ants_fill_from_src = leaf_ants_need_filling)

All_data_v5_plant_leaf_ants_v1 <- All_data_v5_plant_ants_v1 %>%
  left_join(leaf_ants_fill_source_v1, by=c("Date", "location")) %>%
  mutate(Ants_on_leaf_filled = ifelse(is.na(leaf_ants_fill_from_src),
                                       Ants_on_leaf,
                                       Ants_on_leaf_fill))

# manually check that Ants_on_leaf_filled is what you expect before replacing Ants_on_leaf
All_data_v5_plant_leaf_ants_v2 <- All_data_v5_plant_leaf_ants_v1 %>% mutate(Ants_on_leaf = Ants_on_leaf_filled) %>% select(-Ants_on_leaf_filled)
```

## 3.2 - Check that filled empty entries and text conflicts have been resolved
```{r}
# check that the automatic filling worked and address the text conflicts manually in a separate spreadsheet
plant_ants_flagged_v2 <- text_conflict_check(All_data_v5_plant_leaf_ants_v2,
                                             N="Ants_on_plant", perPlant=TRUE) %>%
  select(Date, Dorm, Plant, Ants_on_plant, 
         plant_ants_need_filling = N_need_filling,
         plant_ants_text_conflict = N_text_conflict,
         num_unique_plant_ants = num_unique_N)

## for duplicate leaf entries
leaf_ants_flagged_v2 <- text_conflict_check(All_data_v5_plant_leaf_ants_v2,
                                            N="Ants_on_leaf", perPlant=FALSE) %>%
  select(Date, location, Ants_on_leaf,
         leaf_ants_need_filling = N_need_filling,
         leaf_ants_text_conflict = N_text_conflict,
         num_unique_leaf_ants = num_unique_N)

ant_text_conflict_v2 <- filter(plant_ants_flagged_v2, plant_ants_text_conflict) %>%
  bind_rows(filter(leaf_ants_flagged_v2, leaf_ants_text_conflict))
  
# write_csv(ant_text_conflict, "ant_text_conflict.csv") # resolved 2019-10-08
```

## 3.3 - Split ant species into separate columns, check and revise ant counts per species and total
Note: If the total number of ants on plant is less than the sum of the leaves, recalculated ants_P (i.e. ants on plant); ants on stem could be problematic with this, since some groups of ants are assigned to multiple females, but we tried our best to write in the totals for any plant that had such an ambiguous case, so I think I can just omit stem and apex
```{r}
All_data_v5_plant_leaf_ants_split_v1 <- All_data_v5_plant_leaf_ants_v2 %>% 
  mutate(Ants_on_plant_preprocessed = str_to_lower(str_replace_all(str_trim(Ants_on_plant), pattern = " ", replacement = ""))) %>% # remove all whitespace
  mutate(sbP = as.numeric(str_extract(str_extract(Ants_on_plant, "([0-9]+)sb"), "[0-9]+")),
         brbP = as.numeric(str_extract(str_extract(Ants_on_plant, "([0-9]+)brb"), "[0-9]+")),
         brrbP = as.numeric(str_extract(str_extract(Ants_on_plant, "([0-9]+)brrb"), "[0-9]+")),
         srP = as.numeric(str_extract(str_extract(Ants_on_plant, "([0-9]+)sr"), "[0-9]+")),
         lrP = as.numeric(str_extract(str_extract(Ants_on_plant, "([0-9]+)lr"), "[0-9]+"))) %>%
  mutate(sbL = as.numeric(str_extract(str_extract(Ants_on_leaf, "([0-9]+)sb"), "[0-9]+")),
         brbL = as.numeric(str_extract(str_extract(Ants_on_leaf, "([0-9]+)brb"), "[0-9]+")),
         brrbL = as.numeric(str_extract(str_extract(Ants_on_leaf, "([0-9]+)brrb"), "[0-9]+")),
         srL = as.numeric(str_extract(str_extract(Ants_on_leaf, "([0-9]+)sr"), "[0-9]+")),
         lrL = as.numeric(str_extract(str_extract(Ants_on_leaf, "([0-9]+)lr"), "[0-9]+")))# %>%
  #select(-Ants_on_plant, -Ants_on_leaf, -Ants_on_plant_preprocessed)

All_data_v5_plant_leaf_ants_split_v1_revisions <- All_data_v5_plant_leaf_ants_split_v1 %>% 
  group_by(Date, Dorm, Plant, Leaf) %>%
    filter(row_number() == 1) %>%
  ungroup() %>%
  group_by(Date, Dorm, Plant) %>%
    mutate(sbP_revise = ifelse(!grepl("_S|_A", location),
                               ifelse(is.na(sbP) & !all(is.na(sbL)) | sbP < sum(sbL, na.rm = TRUE),
                                      sum(sbL, na.rm = TRUE),
                                      sbP),
                               sbP),
              brbP_revise = ifelse(!grepl("_S|_A", location),
                               ifelse(is.na(brbP) & !all(is.na(brbL)) | brbP < sum(brbL, na.rm = TRUE),
                                      sum(brbL, na.rm = TRUE),
                                      brbP),
                               brbP),
              brrbP_revise = ifelse(!grepl("_S|_A", location),
                               ifelse(is.na(brrbP) & !all(is.na(brrbL)) | brrbP < sum(brrbL, na.rm = TRUE),
                                      sum(brrbL, na.rm = TRUE),
                                      brrbP),
                               brrbP),
              lrP_revise = ifelse(!grepl("_S|_A", location),
                               ifelse(is.na(lrP) & !all(is.na(lrL)) | lrP < sum(lrL, na.rm = TRUE),
                                      sum(lrL, na.rm = TRUE),
                                      lrP),
                               lrP),
              srP_revise = ifelse(!grepl("_S|_A", location),
                               ifelse(is.na(srP) & !all(is.na(srL)) | srP < sum(srL, na.rm = TRUE),
                                      sum(srL, na.rm = TRUE),
                                      srP),
                               srP)) %>%
  ungroup() %>%
  select(Date, location, sbP_revise, brbP_revise, brrbP_revise, srP_revise, lrP_revise) %>%
  filter(!is.na(location))

# Combine revised ant counts for each species with All_data to create `All_data_v6`
All_data_v6 <- All_data_v5_plant_leaf_ants_split_v1 %>% 
  left_join(All_data_v5_plant_leaf_ants_split_v1_revisions, by = c("Date", "location")) %>%
  select(-sbP, -brbP, -brrbP, -srP, -lrP) %>%
  rename(sbP = sbP_revise, brbP = brbP_revise, brrbP = brrbP_revise, srP = srP_revise, lrP = lrP_revise) %>%
  group_by(row_number()) %>%
    mutate(ants_L = sum(sbL, brbL, brrbL, srL, lrL, na.rm = TRUE),
           ants_P = sum(sbP, brbP, brrbP, srP, lrP, na.rm = TRUE)) %>%
  ungroup() %>%
  select(-`row_number()`, -Ants_on_plant, -Ants_on_leaf, -Ants_on_plant_fill, -plant_ants_fill_from_src, -Ants_on_leaf_fill, -leaf_ants_fill_from_src, -Ants_on_plant_preprocessed)
```

# 4 - Final pass at revising clutch status

## 4.1 - Calculate female visit order to help with visualizing egg guarding timelines
```{r}
visit_order_v1 <- All_data_v6 %>%
  filter(!is.na(Female_ID), !grepl('NA|M|_E|_N|N (dup)', Female_ID)) %>%
  select(Date, location, Female_ID) %>%
  arrange(location, Date) %>%
  group_by(location, Female_ID) %>%
    filter(row_number() == 1) %>%
  ungroup() %>%
  group_by(location) %>%
    mutate(visit_order = rank(Date, ties.method = "min")) %>%
  ungroup() %>%
  select(-Date)

# this just helps with plotting timeline, doesn't deal with visit order ties
visitor_rank_v1 <- All_data_v6 %>%
  filter(!is.na(Female_ID), !grepl('NA|M|_E|_N|N (dup)', Female_ID)) %>%
  filter(!grepl("_S", location)) %>%
  select(Date, location, Female_ID) %>%
  arrange(location, Date) %>%
  group_by(location, Female_ID) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  group_by(location) %>%
  mutate(visitor_rank = rank(Date, ties.method = "random")) %>%
  ungroup() %>%
  select(-Date)

Female_location_visit_order_v1 <- All_data_v6 %>%
  filter(!is.na(Female_ID), !grepl('NA|M|_E|_N|N (dup)', Female_ID)) %>%
  filter(!grepl("_S", location)) %>%
  select(Date, location, Female_ID) %>%
  arrange(location, Date) %>%
  left_join(visit_order_v1) %>%
  left_join(visitor_rank_v1)
```

## 4.2 - Identify "clutch fate": when leaves die / go missing / are 100% eaten
```{r}
## I think it would be helpful to identify when leaves die / go missing / are 100% eaten
Eggs_eaten_dates_v1 <- clutch_status_v2 %>%
  select(location, Date, Clutch_status) %>%
  mutate(eggs_eaten = grepl("eaten", Clutch_status, ignore.case = TRUE)) %>%
  filter(eggs_eaten) %>%
  group_by(location) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(location, eggs_eaten_date = Date)

Leaf_missing_dates_v1 <- clutch_status_v2 %>%
  select(location, Date, Clutch_status) %>%
  mutate(leaf_missing_date = grepl("missing", Clutch_status, ignore.case = TRUE)) %>%
  filter(leaf_missing_date) %>%
  group_by(location) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(location, leaf_missing_date = Date)

Leaf_dead_dates_v1 <- clutch_status_v2 %>%
  select(location, Date, Clutch_status) %>%
  mutate(leaf_dead_date = grepl("dead", Clutch_status, ignore.case = TRUE)) %>%
  filter(leaf_dead_date) %>%
  group_by(location) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(location, leaf_dead_date = Date)

egg_fate_dates_v1 <- clutch_nymph_status_v2 %>%
  left_join(Eggs_eaten_dates_v1) %>%
  left_join(Leaf_missing_dates_v1) %>%
  left_join(Leaf_dead_dates_v1) %>%
  group_by(location) %>%
    filter(row_number() == 1) %>%
    mutate(egg_fate = ifelse(any(!is.na(c(eggs_eaten_date, leaf_missing_date, leaf_dead_date))),
                               ifelse(which.min(c(eggs_eaten_date, leaf_missing_date, leaf_dead_date)) == 1, "Eaten/hatched",
                                       ifelse(which.min(c(eggs_eaten_date, leaf_missing_date, leaf_dead_date)) == 2, "Missing",
                                               ifelse(which.min(c(eggs_eaten_date, leaf_missing_date, leaf_dead_date)) == 3, "Dead",
                                                       NA_character_))),NA_character_)) %>%
  mutate(egg_fate_date = if_else(any(!is.na(c(eggs_eaten_date, leaf_missing_date, leaf_dead_date))),
                            min(c(eggs_eaten_date, leaf_missing_date, leaf_dead_date), na.rm = TRUE),
                            as.Date(NA))) %>%
  select(location, egg_fate, egg_fate_date)
```

## 4.3 - Finalizing initiation and hatch dates (plus leaf fate etc) = "clutch status"
```{r}
clutch_status_init_hatch_v1 <- clutch_nymph_status_v2 %>%
  left_join(initiation_dates_v3, by="location") %>%
  left_join(hatch_dates_v3, by="location") %>%
  left_join(egg_fate_dates_v1, by="location") %>%
  mutate(initiation_date_binary = Date == initiation_date,
         hatch_date_binary = Date == hatch_date,
         egg_fate_date_binary = Date == egg_fate_date) %>%
  left_join(Female_location_visit_order_v1, by=c("Date", "location")) %>%
  select(location, Date, Female_ID, visit_order, Clutch_status, egg_num, egg_len, 
         N1, N2, N5, nymph_origin, NOr_ambiguous, initiation_date, initiation_date_binary, hatch_date, hatch_date_binary, visitor_rank,
         egg_fate, egg_fate_date, egg_fate_date_binary)

clutch_status_init_hatch_v1 %>% filter(egg_len > 50)
clutch_status_init_hatch_v1 %>% filter(location == "A61_10") %>% print(n=Inf)
 
# dates <- as.Date((clutch_status_init_hatch_v1 %>%
#   distinct(Date) %>% arrange(Date))$Date)

clutch_status_last_date_measured_v1 <- clutch_status_init_hatch_v1 %>%
  arrange(location, desc(Date)) %>%
  group_by(location) %>%
    filter(!is.na(egg_len|egg_num)) %>%
    filter(row_number() == 1) %>%
  ungroup()

clutch_status_init_hatch_labels_v1 <- clutch_status_init_hatch_v1 %>%
  mutate(init_label = ifelse(initiation_date_binary,
                             "O",
                             NA_character_),
         hatch_label = ifelse(hatch_date_binary,
                              "H",
                              NA_character_),
         fate_label = ifelse(egg_fate_date_binary,
                              egg_fate,
                              NA_character_)) %>%
  group_by(location, Female_ID) %>%
    arrange(location, Female_ID, desc(Date)) %>%
    mutate(Female_ID_label = ifelse(Date == max(Date),
                                    Female_ID,
                                    NA_character_)) %>%
  ungroup() %>%
  group_by(location) %>%
    mutate(unhatched_days = ifelse(hatch_date_binary, 
                                   paste0(hatch_date-initiation_date, " days"),
                                   NA_character_)) %>%
  ungroup() %>%
  arrange(location, Date)


# exploring the distribution of clutch size metrics
clutch_status_stats_v1 <- clutch_status_init_hatch_labels_v1 %>%
  filter(egg_num > 0 | Clutch_status == "E") %>%
  group_by(location) %>%
    summarize(first_egg_num = first(egg_num),
              min_egg_num = min(egg_num, na.rm = TRUE),
              max_egg_num = max(egg_num, na.rm = TRUE),
              first_egg_len = first(egg_len),
              min_egg_len = min(egg_len, na.rm = TRUE),
              max_egg_len = max(egg_len, na.rm = TRUE),
              initiation_date = first(initiation_date),
              hatch_date = first(hatch_date),
              egg_fate = factor(first(egg_fate)),
              egg_fate_date = first(egg_fate_date),
              any_NOr_ambig_loc = any(NOr_ambiguous)) %>%
  ungroup() %>%
  mutate(unhatched_days = as.integer(hatch_date-initiation_date)) %>%
  left_join(omit_for_abandon_time) %>%
# add number of clutches per plant
  separate(location, c("DormPlant", "Leaf"), "_", remove = FALSE) %>%
  mutate(Dorm = substr(DormPlant, 1,1),
         Plant = substring(DormPlant, 2)) %>%
  group_by(Dorm, Plant) %>%
    mutate(n_clutches_on_plant = n()) %>%
  ungroup() %>%
  select(-Leaf, -DormPlant, -Dorm, -Plant)
```

Note that there is a strong relationship between egg number and clutch length, but the variance increases dramatically at larger numbers of eggs
```{r}
## How tight is the relationship between number of eggs and egg mass length?
ggplot(data = clutch_status_init_hatch_v1, aes(x = egg_len, y = egg_num)) +
  geom_hex() +
  geom_smooth()
```

### [See note] Exporting a list of all clutches with initiation date and hatch date to keep track of revisions
*Note:* Initially I ran this after creating the clutch_status_stats table, but to avoid needing to redo all the calculations/revisions to update clutch_status_stats I moved the data input and revision steps to before I create clutch_status_stats. This would need to be changed if working with the fresh data where "egg_measures_revions" doesn't already exist on the spreadsheet
```{r}
# exporting a list of all clutches with initiation date and hatch date to keep track of revisions
short_unhatched_days_check <- clutch_status_stats_v1 %>% 
  filter(unhatched_days <= 16)

# write_csv(short_unhatched_days_check, "short_unhatched_days_check_tmp.csv")

# *** when is this used for revisions, if ever?
never_hatched_check <- clutch_status_stats_v1 %>% 
  filter(is.na(hatch_date))

# write_csv(never_hatched_check, "never_hatched_check_tmp.csv")

# write_csv(clutch_status_stats_v1, "egg_measures_check_tmp.csv")
```

# 5 - Creating a table with relative guarding times
This will be used for most of the downstream analyses.

## 5.1 - Identify initiators, create visit/guard summaries (first pass)
Creates `initiators`, `visit_durations_summary`, `clutch_durations_summary` and `num_clutches_initiated`
```{r}
initiators <- Female_location_visit_order_v1 %>%
  arrange(Female_ID, Date) %>%
  left_join(initiation_dates_v3, by = "location") %>%
  left_join(hatch_dates_v3, by = "location") %>%
  filter(!is.na(initiation_date), Date == initiation_date) %>%
  arrange(location, Date, visit_order) %>%
  group_by(location) %>%
    # "first visitor initiator" means she was present at init and was the first female on the leaf
    mutate(first_visitor_initiator = rank(visit_order, ties.method = "min") == 1) %>%
  ungroup() %>%
  group_by(location) %>%
    mutate(num_at_init = n()) %>%
  ungroup() %>%
  select(-Date)

visit_durations_summary <- Female_location_visit_order_v1 %>%
  left_join(initiation_dates_v3, by = "location") %>%
  left_join(hatch_dates_v3, by = "location") %>%
  arrange(location, Date) %>%
  group_by(Female_ID, location) %>%
    summarize(visit_starts = first(Date),
              visit_ends = last(Date),
            visit_duration = last(Date) - first(Date),
            guard_duration = last(Date) - max(first(Date, first(initiation_date))),
            relative_desert_date = last(Date) - first(hatch_date)) %>%
  ungroup() %>%
  arrange(Female_ID, visit_starts) %>%
  group_by(Female_ID) %>%
    mutate(leaf_visit_order = rank(visit_starts, ties.method = "min")) %>%
  ungroup()

# add clutch_order (the order of the clutch a female has initiated)
clutch_durations_summary <- visit_durations_summary %>%
  right_join(initiators) %>%
  group_by(location) %>% 
    mutate(duration_rank = rank(desc(guard_duration), ties.method="min")) %>%
  ungroup() %>%
  group_by(Female_ID) %>%
    arrange(visit_starts) %>%
    # moms that were on the leaf first and were there at init are considered initiators
    mutate(initiator = ifelse(first_visitor_initiator & num_at_init == 1, 
                              TRUE,
                              # break ties by assuming longest guarder was init and marked female was init
                              ifelse(first_visitor_initiator & duration_rank == 1 & !grepl("U", Female_ID), 
                                     TRUE,
                                     FALSE)),
           # if the visit ends while a clutch is present
           clutch_visited_order = ifelse(visit_ends >= initiation_date,
                                         # find the order of the clutch visit
                                         rank(visit_starts, ties.method = "min"),
                                         # otherwise, the female visited before init (rank = 0)
                                         0) 
    ) %>%
  ungroup() %>%
  group_by(Female_ID, initiator) %>%
    # if the mom is the initiator
    mutate(clutch_initiated_order = ifelse(initiator, 
                                    # find the order of the clutch visit
                                    rank(visit_starts, ties.method = "min"), 
                                    # otherwise, this doesn't count as an initiation
                                    NA)) %>% 
  ungroup() %>%
  arrange(Female_ID) %>%
  mutate(Dorm = substr(location, 1,1)) %>%
  mutate(females_removed = Dorm %in% c("D", "F", "G", "H"),
         ants_removed = Dorm %in% c("C", "B", "F", "H"))

num_clutches_initiated <- clutch_durations_summary %>%
  group_by(Dorm, Female_ID) %>%
    summarize(num_clutches_initiated = max(clutch_initiated_order),
              females_removed = first(females_removed)) %>%
  ungroup()
```

## 5.2 - Last date female was observed
Last date female observed, so I have the option of filtering out females that probably died rather than leaving on their own fruition
```{r}
last_day_fID <- All_data_v6 %>%
#  mutate(females_removed = Dorm %in% c("D", "F", "G", "H"),
#         ants_removed = Dorm %in% c("C", "B", "F", "H")) %>%
  group_by(Female_ID, Dorm) %>% #, females_removed, ants_removed) %>%
  summarize(last_day_fID = max(Date)) %>%
  ungroup()

# ggplot(filter(last_day_fID, !females_removed)) + 
#   geom_freqpoly(aes(x = last_day_fID, after_stat(density), color = ants_removed))

# clutch_durations_summary_v2 %>% 
#   filter(mom_at_init)
```

## 5.3 - Summary of secondary visitor behavior
Need to differentiate visit days before eggs present from "guard" days after initiation.
```{r}
visit_durations_summary_v2 <- Female_location_visit_order_v1 %>%
  left_join(initiation_dates_v3, by = "location") %>%
  left_join(hatch_dates_v3, by = "location") %>%
  arrange(location, Date) %>%
  group_by(Female_ID, location) %>%
    summarize(visit_starts = first(Date),
              visit_ends = last(Date),
            visit_duration = visit_ends - visit_starts,
            # duration of visit after initiation (NA if did not visit while eggs present)
            guard_duration = ifelse(visit_ends - max(visit_starts, first(initiation_date)) >= 0,
                                    visit_ends - max(visit_starts, first(initiation_date)),
                                    NA),
            relative_desert_date = visit_ends - first(hatch_date),
            initiation_date = first(initiation_date),
            hatch_date = first(hatch_date)) %>%
  ungroup() %>%
  arrange(Female_ID, visit_starts) %>%
  group_by(Female_ID) %>%
    mutate(leaf_visit_order = rank(visit_starts, ties.method = "min")) %>%
  ungroup() %>%
  arrange(location, visit_starts)
```

## 5.4 Alternatives to determining who is the initiator
Create `clutch_durations_summary_v2` and `clutch_status_guarding_summary_v2` after identify the "longest initiator" and `shortest initiator` for each clutch, corresponding to the mother at initiation that was there the longest prior to eggs being observed and (1) remained guarding the clutch the longest after initiation or (2) deserted the clutch the earliest after initiation, respectively.
```{r}
num_at_init <- initiators %>%
  distinct(location, num_at_init) 

clutch_durations_summary_v2 <- visit_durations_summary_v2 %>%
  left_join(select(initiators, -initiation_date, -hatch_date, -num_at_init)) %>%
  left_join(num_at_init, by = "location") %>%
  # note: includes small num of moms on a leaf before init, left before init, then returned
  mutate(mom_at_init = ifelse(visit_starts <= initiation_date & visit_ends >= initiation_date,
                              TRUE,
                              FALSE)) %>%
  group_by(location) %>% 
    mutate(init_dur_rank = rank(desc(ifelse(mom_at_init, guard_duration, NA)),
                                ties.method="min", na.last = "keep"),
           init_dur_shortest = rank(ifelse(mom_at_init, guard_duration, NA),
                                ties.method="min", na.last = "keep") == 1,
           init_first_dur_rank = rank(desc(ifelse(first_visitor_initiator, guard_duration, NA)),
                                ties.method="min", na.last = "keep"),
           init_first_dur_shortest = rank(ifelse(first_visitor_initiator, guard_duration, NA),
                                ties.method="min", na.last = "keep") == 1) %>%
  ungroup() %>%
  # mutate(init_long = init_dur_rank == 1,
  #        init_short = init_dur_shortest,
  #        init_first_long = init_first_dur_rank == 1,
  #        init_first_short = init_first_dur_shortest) %>%
  group_by(Female_ID) %>%
    # if the visit ends while a clutch is present
    mutate(clutch_visited_order = ifelse(visit_ends >= initiation_date,
                                         # find the order of the clutch visit
                                         rank(visit_starts, ties.method = "min"),
                                         # otherwise, the female visited before init (rank = 0)
                                         0),
           clutch_initiated_order = rank(ifelse(mom_at_init, visit_starts, NA),
                                         ties.method = "min", na.last = "keep"),
           clutch_init_first_order = rank(ifelse(first_visitor_initiator, visit_starts, NA),
                                          ties.method = "min", na.last = "keep")) %>%
           # clutch_init_long_order = rank(ifelse(init_long, visit_starts, NA),
           #                         ties.method = "min", na.last = "keep"),
           # clutch_init_first_long_order = rank(ifelse(init_first_long, visit_starts, NA),
           #                         ties.method = "min", na.last = "keep"),
           # clutch_init_first_short_order = rank(ifelse(init_first_short, visit_starts, NA),
           #                         ties.method = "min", na.last = "keep")) %>% 
  ungroup() %>%
  arrange(location, visit_starts) %>%
  mutate(Dorm = substr(location,1,1),
         females_removed = Dorm %in% c("D", "F", "G", "H"),
         ants_removed = Dorm %in% c("C", "B", "F", "H"))

clutch_status_guarding_summary_v2 <- clutch_durations_summary_v2 %>%
  left_join(select(clutch_status_stats_v1, -initiation_date, -hatch_date), by = "location") %>%
  left_join(select(num_clutches_initiated, -females_removed), by=c("Dorm", "Female_ID")) %>%
  left_join(select(check_hatch_date_revisions, location, hatch_date_check = revised_hatch_date_text), by="location") %>%
  left_join(select(short_unhatched_check_revisions, location, short_unhatched_check = Egg_revisions), by="location") %>%
  # "never_hatched" should be used to override the automatically generated hatch date based on presence of nymphs
  # but this work has already been done by check_hatch_date_revisions and short_unhatched_check_revisions revisions
  # so this column isn't really useful for anything
  mutate(never_hatched = grepl("never hatched", hatch_date_check) | grepl("never hatched", short_unhatched_check)) %>%
  select(-hatch_date_check, -short_unhatched_check)
```

# 6 - Write data for `Publilia-02-strats.Rmd` to `.rds` for further analysis in clean environment

## `Publilia-02-strats.Rmd`
```{r}
write_rds(All_data_v6, here("saved_rds/All_data_v6.rds"))
write_rds(clutch_status_guarding_summary_v2, here("saved_rds/clutch_status_guarding_summary_v2.rds"))
write_rds(last_day_fID, here("saved_rds/last_day_fID.rds"))
```



***

*Prep data for `Publilia-03-survivorship.Rmd`:*

# 7 - Assigning nymph origins

Nymphs migrate away from their natal leaf. On plants with multiple clutches, it was sometimes possible to determine the origin of nymphs later in the season because sometimes groups of nymph don't travel very far from their natal leaf and mix with other groups. I manually curated examples of this, so that clutch-level stats on hatching success and nymph survivorship could be determined on the plants with multiple clutches. Some clutches (as a rule only on multi-clutch plants) did not have a clear record of nymphs that emigrated from the natal leaf and thus could not be included in future clutch-level analyses of survivorship.

## 7.1 - Adding second gen adult counts per leaf to clutch status stats
```{r}
# counting adults
eA_status_v1 <- All_data_v6 %>%
  group_by(row_number()) %>% # sum of newly exclosed adults
  filter(any(!is.na(c(New_eA, Old_eA)))) %>%
  mutate(n_newA = ifelse(is.na(New_eA),
                         NA,
                         sum(as.numeric(regmatches(New_eA, gregexpr("[0-9]+", New_eA))[[1]]))),
         n_oldA = ifelse(is.na(Old_eA),
                         NA,
                         sum(as.numeric(regmatches(Old_eA, gregexpr("[0-9]+", Old_eA))[[1]]))),
         n_A = sum(n_newA, n_oldA, na.rm = TRUE)) %>%
  ungroup() %>%
  select(Date, location, n_newA, n_oldA, n_A)

All_data_v6_clutch_status_stats_v2 <- All_data_v6 %>%
  # add egg measures, clutch status stats (including initiation dates, hatch dates, egg fate, etc)
  left_join(clutch_status_v2, by = c("location", "Date")) %>%
  left_join(clutch_status_stats_v1, by = c("location")) %>%
  left_join(eA_status_v1, by = c("Date", "location")) %>%
  left_join(select(clutch_status_guarding_summary_v2, location, never_hatched)) %>%
  mutate(N1 = as.numeric(N1),
         N2 = as.numeric(N2),
         N5 = as.numeric(N5))
```

## 7.2 - Manually check nymph origins for revision
First create a table of all entried from clutches that were not flagged in the field as having ambiguous origin (e.g. "leaf 6 or 9") in cases were more than one clutch was on the plant. These were revised manually to specify a leaf of origin for the nymphs, where possible.
```{r}
NOr_status_resolveable_all_unambig_clutches <- All_data_v6_clutch_status_stats_v2 %>% 
  select(Date, Dorm, Plant, Leaf, location, 
         egg_num, N1, N2, N5, n_A, nymph_origin, initiation_date, hatch_date,
         any_NOr_ambig_loc, Omit_for_abandon_time, never_hatched,
         n_clutches_on_plant) %>%
  # keep only entries with some nymphs or adults on a leaf
  # OR entries for leaves where clutches have been initiated
  group_by(row_number()) %>%
  filter(!is.na(Leaf) & any(N1 > 0, N2 > 0, N5 > 0, n_A > 0) | 
           Date >= initiation_date) %>% # nrow = 17944
  # flag entries where the nymph origin is text (typically ambiguous, e.g. "8 or 9")
  mutate(NOr_ambig_entry = !is.na(nymph_origin) & is.na(as.numeric(nymph_origin))) %>% 
  ungroup() %>%
  # get rid of duplicate rows from multiple females in the same location
  distinct(Date, location, .keep_all = TRUE) %>% # nrow = 15674
  group_by(Dorm, Plant) %>%
    # filter out any plants with a clutch that was omitted for abandon time
    filter(!any(!is.na(Omit_for_abandon_time))) %>%
    # flag plants with any ambiguous entries (e.g. "8 or 9") skip for checking
    mutate(NOr_ambig_plant = any(NOr_ambig_entry)) %>%
  ungroup()

NOr_status_resolveable_mult_clutches <- NOr_status_resolveable_all_unambig_clutches %>% # nrow = 15674
  group_by(Dorm, Plant) %>%
    # plants with mutliple clutches only
    filter(any(n_clutches_on_plant > 1)) %>%
  ungroup() %>%
  group_by(row_number()) %>%
    # flag for manual checking entries with any nymphs/adults, missing nymph origin, 
    # but not flagged for ambiguous origin in the field.
    # these are the most likely to be easily resolved with minimal work
    mutate(revise_NOr = ifelse(any(N1 > 0, N2 > 0, N5 > 0, n_A > 0) &
             !NOr_ambig_plant,
           "MANUAL CHECK",
           NA)) %>% 
  ungroup()

NOr_manual_check_table <- NOr_status_resolveable_mult_clutches %>%
  group_by(Dorm, Plant) %>%
    filter(any(revise_NOr == "MANUAL CHECK")) %>% # nrow = 2830
  ungroup() %>%
    group_by(row_number()) %>%
    filter(any(N1 > 0, N2 > 0, N5 > 0, n_A > 0)) %>%
  ungroup() %>%
  select(Date, Dorm, Plant, Leaf, location, egg_num, N1, N2, N5, n_A, nymph_origin,
         initiation_date, hatch_date,
         revise_NOr) %>%
  arrange(Dorm, as.numeric(Plant), as.numeric(Leaf), Date)
# 83 clutches on 34 plants to check

# write_csv(NOr_manual_check_table %>% filter(revise_NOr == "MANUAL CHECK"), "NOr_manual_check_tmp.csv")

NOr_manual_revisions <- read_xlsx(in_filename, sheet = "NOr_manual_check", col_types = c("date", "text", "text", "text", "text", "text", "text", "text", "text", "text", "text", "text", "text", "text", "logical", "text")) %>%
  mutate(Date = as_date(Date),
         NOr_rev_loc_manual = paste0(Dorm, Plant, "_", NOr_revised)) %>%
  filter(!cant_resolve) %>%
  select(Date, location, NOr_rev_loc_manual, NOr_revised_manual = NOr_revised)

NOr_manual_revisions %>%
  distinct(NOr_rev_loc_manual) # 43/83 initiated clutches (43/59 hatched) with successfully revised NOr
```

## 7.3 - Implement revisions by creating the new variables NOr_revised and NOr_rev_loc
```{r}
# if nymph origin was clearly resolveable, the revisions were made in NOr_manual_revisions
# updating NOr_status with revisions so that it can be left_joined to other data and
# counts of nymphs and adults on NOr can be calculated
NOr_status_revised_all_unambig_clutches <- NOr_status_resolveable_all_unambig_clutches %>%
  left_join(NOr_manual_revisions, by = c("Date", "location")) %>%
  group_by(Dorm, Plant) %>%
    mutate(lone_hatcher_leaf = ifelse(length(unique(Leaf[!is.na(initiation_date)])) == 1,
                                 unique(Leaf[!is.na(initiation_date)]),
                                 NA),
           NOr_revised = ifelse(!is.na(NOr_revised_manual),
                                       NOr_revised_manual,
                                ifelse(any(!is.na(lone_hatcher_leaf)),
                                       lone_hatcher_leaf,
                                       # if no clutches hatched on the plant, NOr_revised = Leaf
                                       # for leaves with eggs
                                       ifelse(!any(!is.na(hatch_date)) & !is.na(egg_num),
                                              Leaf,
                                              NA)))) %>%
  ungroup() %>%  
  group_by(location) %>%
    mutate(NOr_revised = ifelse(any(NOr_revised == Leaf) & is.na(NOr_revised),
                                Leaf,#unique(NOr_revised[!is.na(NOr_revised)]),
                                NOr_revised)) %>%
  ungroup() %>%
  mutate(NOr_rev_loc = ifelse(is.na(NOr_revised),
                              NA,
                              paste0(Dorm, Plant, "_", NOr_revised))) %>%
  select(Date, location, NOr_revised, NOr_rev_loc) %>%
  filter(!is.na(NOr_rev_loc))

All_data_v6_N_NOr_counts_unambig_clutches <- All_data_v6_clutch_status_stats_v2 %>%
  right_join(NOr_status_revised_all_unambig_clutches, by = c("Date", "location")) %>%
  group_by(Date, Dorm, Plant, NOr_revised, NOr_rev_loc) %>%
    summarize(N1_NOr = sum(N1, na.rm= TRUE),
              N2_NOr = sum(N2, na.rm= TRUE),
              N5_NOr = sum(N5, na.rm= TRUE),
              N_NOr = sum(N1, N2, N5, na.rm = TRUE),
              A_NOr = sum(n_A, na.rm= TRUE),
              N5plusA_NOr = sum(N5, n_A, na.rm= TRUE)) %>%
  ungroup() # n = 186

All_data_v6_N_NOr_counts_unambig_clutches_summary <- All_data_v6_N_NOr_counts_unambig_clutches %>%
  group_by(Date) %>%
    mutate(mean_N_NOr = mean(N_NOr, na.rm = TRUE),
           mean_N1_NOr = mean(N1_NOr, na.rm = TRUE),
           mean_N2_NOr = mean(N2_NOr, na.rm = TRUE),
           mean_N5_NOr = mean(N5_NOr, na.rm = TRUE),
           mean_A_NOr = mean(A_NOr, na.rm = TRUE),
           mean_N5plusA_NOr = mean(N5plusA_NOr, na.rm = TRUE),
           All_N_NOr = sum(N_NOr),
           All_A_NOr = sum(A_NOr)) %>%
  ungroup() %>%
  group_by(Date, Dorm) %>%
    mutate(All_N_NOr_Dorm = sum(N_NOr),
           All_N1_NOr_Dorm = sum(N1_NOr),
           All_N2_NOr_Dorm = sum(N2_NOr),
           All_N5_NOr_Dorm = sum(N5_NOr),
           All_A_NOr_Dorm = sum(sum(A_NOr))) %>%
  ungroup()

All_data_v6_all_nymphs_unambig_clutches <- All_data_v6_N_NOr_counts_unambig_clutches %>%
  group_by(Date) %>%
    summarize(All_N_NOr = sum(N_NOr)) %>%
  ungroup()

All_data_v6_max_N_NOr_counts_unambig_clutches <-
  All_data_v6_N_NOr_counts_unambig_clutches %>%
  group_by(Dorm, Plant, NOr_revised, NOr_rev_loc) %>%
    summarize(max_N_NOr = max(N_NOr)) %>%
  ungroup()
  
clutch_status_stats_v1_unambig_clutches_hatch_success <- clutch_status_stats_v1 %>%
  separate(location, c("DormPlant", "Leaf"), sep = "_", remove = FALSE) %>%
  mutate(Dorm = substr(DormPlant, 1, 1),
         Plant = substring(DormPlant, 2)) %>%
  left_join(distinct(clutch_status_guarding_summary_v2, location, never_hatched)) %>%
  right_join(All_data_v6_max_N_NOr_counts_unambig_clutches, by = c("Dorm", "Plant", "Leaf" = "NOr_revised")) %>%
  # why did I originally say to make hatch_success = NA if never_hatched == TRUE?
  mutate(hatch_success = ifelse(!is.na(initiation_date) & is.na(hatch_date),
                                0,
                                max_N_NOr/max_egg_num))
```

## 7.4 - Flag and resolve ambiguous nymph origins

```{r}
NOr_status_resolveable_all_unambig_clutches <- All_data_v6_clutch_status_stats_v2 %>% 
  select(Date, Dorm, Plant, Leaf, location, 
         egg_num, N1, N2, N5, n_A, nymph_origin, initiation_date, hatch_date,
         any_NOr_ambig_loc, Omit_for_abandon_time, never_hatched,
         n_clutches_on_plant) %>%
  # keep only entries with some nymphs or adults on a leaf
  # OR entries for leaves where clutches have been initiated
  group_by(row_number()) %>%
  filter(!is.na(Leaf) & any(N1 > 0, N2 > 0, N5 > 0, n_A > 0) | 
           Date >= initiation_date) %>% # nrow = 17944
  # flag entries where the nymph origin is text (typically ambiguous, e.g. "8 or 9")
  mutate(NOr_ambig_entry = !is.na(nymph_origin) & is.na(as.numeric(nymph_origin))) %>% 
  ungroup() %>%
  # get rid of duplicate rows from multiple females in the same location
  distinct(Date, location, .keep_all = TRUE) %>% # nrow = 15674
  group_by(Dorm, Plant) %>%
    # filter out any plants with a clutch that was omitted for abandon time
    filter(!any(!is.na(Omit_for_abandon_time))) %>%
    # flag plants with any ambiguous entries (e.g. "8 or 9") skip for checking
    mutate(NOr_ambig_plant = any(NOr_ambig_entry)) %>%
  ungroup()

NOr_status_resolveable_mult_clutches <- NOr_status_resolveable_all_unambig_clutches %>%
  group_by(Dorm, Plant) %>%
    # plants with mutliple clutches only
    filter(any(n_clutches_on_plant > 1)) %>%
  ungroup() %>%
  group_by(row_number()) %>%
    # flag for manual checking entries with any nymphs/adults, missing nymph origin, 
    # but not flagged for ambiguous origin in the field.
    # these are the most likely to be easily resolved with minimal work
    mutate(revise_NOr = ifelse(any(N1 > 0, N2 > 0, N5 > 0, n_A > 0) &
             !NOr_ambig_plant,
           "MANUAL CHECK",
           NA)) %>% 
  ungroup()
```


## 7.5 - Fixing the omission of clutches that never had first instar nymphs

```{r}
NOr_status_revised_all_unambig_clutches_v2 <- NOr_status_resolveable_all_unambig_clutches %>%
  left_join(NOr_manual_revisions, by = c("Date", "location")) %>%
  group_by(Dorm, Plant) %>%
    mutate(lone_hatcher_leaf = ifelse(length(unique(Leaf[!is.na(initiation_date)])) == 1,
                                 unique(Leaf[!is.na(initiation_date)]),
                                 NA),
           NOr_revised = ifelse(!is.na(NOr_revised_manual), # if I manually annotated a revised location
                                       NOr_revised_manual, # make manual location the new nymph origin
                                ifelse(any(!is.na(lone_hatcher_leaf)), # if only one clutch hatched on the plant
                                       lone_hatcher_leaf, # make that clutch the new nymph origin
                                       # if no clutches hatched on the plant, NOr_revised = Leaf
                                       # for leaves with eggs
                                       ifelse(!any(!is.na(hatch_date)) & !is.na(egg_num), # if no clutches hatched on the plant (but there are eggs)
                                              Leaf, # make the given leaf the new nymph origin
                                              NA)))) %>% # BUT THIS STILL EXCLUDES CLUTCHES THAT DIDN'T HATCH ON A PLANT WITH SOME CLUTCHES THAT DID HATCH
  ungroup() %>%  
  group_by(location) %>%
    mutate(NOr_revised = ifelse(any(NOr_revised == Leaf) & is.na(NOr_revised), # DOES THIS INCLUDE UNHATCHED CLUTCHES? NO
                                Leaf,#unique(NOr_revised[!is.na(NOr_revised)]),
                                NOr_revised),
           NOr_revised = ifelse(any(is.na(NOr_revised)) & # if no revised nymph origin yet
                                                  any(!is.na(egg_num)&egg_num>0 & !any(!is.na(N1)&N1>0)), # and N1 never on clutch (not hatched or spuriously visited by N1)
                                Leaf, # make this leaf the new nymph origin (so we include unhatched clutches)
                                NOr_revised)) %>% 
  ungroup() %>%
  mutate(NOr_rev_loc = ifelse(is.na(NOr_revised),
                              NA,
                              paste0(Dorm, Plant, "_", NOr_revised))) %>%
  select(Date, location, NOr_revised, NOr_rev_loc) %>%
  filter(!is.na(NOr_rev_loc))

All_data_v6_N_NOr_counts_unambig_clutches_v2 <- All_data_v6_clutch_status_stats_v2 %>%
  right_join(NOr_status_revised_all_unambig_clutches_v2, by = c("Date", "location")) %>%
  group_by(Date, Dorm, Plant, NOr_revised, NOr_rev_loc) %>%
    summarize(N1_NOr = sum(N1, na.rm= TRUE),
              N2_NOr = sum(N2, na.rm= TRUE),
              N5_NOr = sum(N5, na.rm= TRUE),
              N_NOr = sum(N1, N2, N5, na.rm = TRUE),
              A_NOr = sum(n_A, na.rm= TRUE),
              N5plusA_NOr = sum(N5, n_A, na.rm= TRUE)) %>%
  ungroup()
 
All_data_v6_N_NOr_counts_unambig_clutches_summary_v2 <- All_data_v6_N_NOr_counts_unambig_clutches_v2 %>%
  group_by(Date) %>%
    mutate(mean_N_NOr = mean(N_NOr, na.rm = TRUE),
           mean_N1_NOr = mean(N1_NOr, na.rm = TRUE),
           mean_N2_NOr = mean(N2_NOr, na.rm = TRUE),
           mean_N5_NOr = mean(N5_NOr, na.rm = TRUE),
           mean_A_NOr = mean(A_NOr, na.rm = TRUE),
           mean_N5plusA_NOr = mean(N5plusA_NOr, na.rm = TRUE),
           All_N_NOr = sum(N_NOr),
           All_A_NOr = sum(A_NOr)) %>%
  ungroup() %>%
  group_by(Date, Dorm) %>%
    mutate(All_N_NOr_Dorm = sum(N_NOr),
           All_N1_NOr_Dorm = sum(N1_NOr),
           All_N2_NOr_Dorm = sum(N2_NOr),
           All_N5_NOr_Dorm = sum(N5_NOr),
           All_A_NOr_Dorm = sum(sum(A_NOr))) %>%
  ungroup()
```


# 8 - Calculate hatch success and nymph survivorship

Calculate hatch success (strict sense; max N1 / max eggs) and nymph survivorship (max N5+A / max eggs AND/OR max N5+A / max N1)

- Filtered out clutches with outlier numbers of N1 or N5 etc at early or late clutch ages, which were assumed to be cases of immigration that weren't caught during manual nymph origin filtering
```{r}
# Filter to only include curated list of clutches with unambiguous nymph counts after accounting for immigration to non-natal leaves and then sum all nymphs (including emigrants) for each clutch
# I also added clutch_age variables to help identify clutches that were started too close to the end of sampling to be useful
clutch_unambig_NOr_revised_ENAa_summary_v2 <- All_data_v6_clutch_status_stats_v2 %>%
  right_join(NOr_status_revised_all_unambig_clutches_v2, by = c("Date", "location")) %>%
  select(Date, NOr_rev_loc, location, egg_num, N1, N2, N5, n_A, ants_L) %>%
    # remove any duplicates - I need to figure out why there are dups later but for 4th yr talk
  distinct(Date, NOr_rev_loc, location, egg_num, N1, N2, N5, n_A, ants_L, .keep_all = TRUE) %>%
  mutate(egg_num_NOr = ifelse(NOr_rev_loc == location, egg_num, NA)) %>%
  group_by(Date, NOr_rev_loc) %>%
    summarize(eggs_NOr = first(egg_num_NOr[!is.na(egg_num_NOr)]), # only use eggs from origin leaf!
              N1_NOr = sum(N1, na.rm= TRUE),
              N2_NOr = sum(N2, na.rm= TRUE),
              N5_NOr = sum(N5, na.rm= TRUE),
              N_NOr = sum(N1, N2, N5, na.rm = TRUE),
              A_NOr = sum(n_A, na.rm= TRUE),
              N5toA_NOr = sum(N5, n_A, na.rm= TRUE),
              ants_NOr = sum(ants_L, na.rm = TRUE)) %>%
  ungroup() %>%
  left_join(filter(clutch_status_guarding_summary_v2, mom_at_init), by = c("NOr_rev_loc" = "location")) %>%
  mutate(clutch_age1 = Date - initiation_date,
         clutch_age2 = ceiling((Date - initiation_date)/2)*2,
         clutch_age4 = ceiling((Date - initiation_date)/4)*4,
         after_hatch1 = Date - hatch_date,
         after_hatch2 = ceiling((Date - hatch_date)/2)*2,
         after_hatch4 = ceiling((Date - hatch_date)/4)*4) %>%
  select(Date, NOr_rev_loc, clutch_age1, after_hatch1, eggs_NOr, 
         N1_NOr, N2_NOr, N5_NOr, N_NOr, A_NOr, N5toA_NOr, ants_NOr,
         init_fem = Female_ID,
         initiation_date, hatch_date, guard_duration, relative_desert_date,
         clutch_initiated_order, females_removed, ants_removed, 
         clutch_age2, clutch_age4, after_hatch2, after_hatch4) #%>%
  # filter(initiation_date <= as_date("2019-06-10"),
  #        clutch_age4 <= 68)

max_N1_date_v2 <- clutch_unambig_NOr_revised_ENAa_summary_v2 %>%
  group_by(NOr_rev_loc) %>%
  arrange(NOr_rev_loc, desc(N1_NOr), Date) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(NOr_rev_loc, max_N1_date = Date, max_N1_age = clutch_age1)

max_N5_date_v2 <- clutch_unambig_NOr_revised_ENAa_summary_v2 %>%
  group_by(NOr_rev_loc) %>%
  arrange(NOr_rev_loc, desc(N5_NOr), Date) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(NOr_rev_loc, max_N5_date = Date, max_N5_age = clutch_age1)

max_A_date_v2 <- clutch_unambig_NOr_revised_ENAa_summary_v2 %>%
  group_by(NOr_rev_loc) %>%
  arrange(NOr_rev_loc, desc(A_NOr), Date) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(NOr_rev_loc, max_A_date = Date, max_A_age = clutch_age1)

max_N5toA_date_v2 <- clutch_unambig_NOr_revised_ENAa_summary_v2 %>%
  group_by(NOr_rev_loc) %>%
  arrange(NOr_rev_loc, desc(N5toA_NOr), Date) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(NOr_rev_loc, max_N5toA_date = Date, max_N5toA_age = clutch_age1)

max_N5toA_Date_v2 <- clutch_unambig_NOr_revised_ENAa_summary_v2 %>%
  group_by(NOr_rev_loc) %>%
  summarize(max_N1 = max(N1_NOr),
            max_N5toA = max(N5toA_NOr),
            max_clutch_age = max(clutch_age1),
            max_after_hatch = max(after_hatch1),
            max_Date = max(Date),
            hatched = any(!is.na(hatch_date)),
            initiation_date = first(initiation_date)) %>%
  ungroup() %>%
  arrange(desc(max_N5toA)) %>%
  full_join(max_N1_date_v2) %>%
  full_join(max_N5_date_v2) %>%
  full_join(max_A_date_v2) %>%
  full_join(max_N5toA_date_v2)

clutch_unambig_NOr_revised_ENAa_summary_imfilt_v2 <- clutch_unambig_NOr_revised_ENAa_summary_v2 %>%
  mutate(N_imm_likely_d15 = clutch_age1 < 15 & N_NOr > 0,
         N5_imm_likely_d40 = clutch_age1 < 40 & N5_NOr > 0,
         A_imm_likely_d40 = clutch_age1 < 40 & A_NOr > 0) %>%
  group_by(NOr_rev_loc) %>%
    filter(!any(N_imm_likely_d15, N5_imm_likely_d40, A_imm_likely_d40, na.rm = TRUE)) %>% # n = 168
  ungroup()
          
clutch_unambig_NOr_revised_ENAa_summary_imfilt_success_v2 <-
  clutch_unambig_NOr_revised_ENAa_summary_imfilt_v2 %>%
  group_by(NOr_rev_loc) %>%
    mutate(hatch_success_N1 = max(N1_NOr, na.rm = TRUE)/max(eggs_NOr, na.rm = TRUE),
           survival_rate = max(N5toA_NOr, na.rm = TRUE)/max(eggs_NOr, na.rm = TRUE),
           prop_E2Ni = max(N1_NOr, na.rm = TRUE)/max(eggs_NOr, na.rm = TRUE),
           prop_E2N = max(N_NOr, na.rm = TRUE)/max(eggs_NOr, na.rm = TRUE),
           prop_Ni2Nv = max(N5toA_NOr, na.rm = TRUE)/max(N1_NOr, na.rm = TRUE),
           prop_E2Nv = max(N5toA_NOr, na.rm = TRUE)/max(eggs_NOr, na.rm = TRUE),
           n_eggs = max(eggs_NOr, na.rm = TRUE),
           n_hatched = max(N1_NOr, na.rm = TRUE),
           n_N = max(N_NOr, na.rm = TRUE),
           n_survived = max(N5toA_NOr, na.rm = TRUE)) %>%
  ungroup()

clutch_unambig_NOr_revised_ENAa_summary_imfilt_success_summary_v2 <- clutch_unambig_NOr_revised_ENAa_summary_imfilt_success_v2 %>%
  distinct(NOr_rev_loc, n_eggs, n_hatched, n_survived, n_N,
           prop_E2Ni, prop_Ni2Nv, prop_E2Nv, prop_E2N, hatch_success_N1, survival_rate,
           initiation_date, hatch_date, females_removed, ants_removed) 
```

# 9 - Ant counts on clutch

```{r}
theme_publilia <- function(){
  theme_bw() +
    theme(text = element_text(family = "Arial"),
          axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          axis.line.x = element_line(color="black"), 
          axis.line.y = element_line(color="black"),
          panel.border = element_blank(),
          panel.grid.major.x = element_blank(),                                          
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.grid.major.y = element_blank(),  
          plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), units = , "cm"),
          plot.title = element_text(size = 18, vjust = 1, hjust = 0.5, face = "bold"),
          legend.text = element_text(size = 10),          
          legend.title = element_blank(),                              
          # legend.position = c(0.90, 0.90), 
          legend.key = element_blank(),
          legend.background = element_rect(color = "black", 
                                           fill = "transparent", 
                                           size = 2, linetype = "blank"))
}
```


## 9.0 - Get visited_1st_4d_data

```{r}
strats_data <- left_join(clutch_status_guarding_summary_v2, last_day_fID)

visited_1st_4d_data <- strats_data %>%
  group_by(location) %>%
    mutate(visited_1st_4d = any(!mom_at_init & as.numeric(visit_starts-initiation_date)<=4)) %>%
  ungroup() %>%
  mutate(`visited in 4 days` = ifelse(visited_1st_4d | num_at_init>1,
                                      "Visited", "Not visited"),
         ants = ifelse(ants_removed, "Ants removed", "Control"),
         est_hatch = as_date(ifelse(is.na(hatch_date),
                                 initiation_date + 20,
                                 hatch_date)),
         est_rel2h = visit_ends-est_hatch)
```

```{r}
visited_1st_4d_data_tb <- visited_1st_4d_data %>%
  # 1) Longest initiator
  mutate(initL = init_first_dur_rank == 1) %>% 
  # 2) Shortest initiator
  #  i) break ties by picking marked females over unmarked
  group_by(location, init_first_dur_shortest) %>% 
    mutate(initS_tmp = ifelse(n()>1, !grepl("Uf", Female_ID), TRUE)) %>% 
  ungroup() %>%
  #  ii) finally picking at random (only one case, identical predictor vars)
  group_by(location, init_first_dur_shortest, initS_tmp) %>%
    mutate(initS = init_first_dur_shortest & initS_tmp & row_number()==1) %>%
  ungroup()
```


## 9.1 - A small fraction of ants_removed clutches were visited by ants, and vice versa
```{r}
ant_counts <- All_data_v6 %>%
  left_join(select(visited_1st_4d_data, location, initiation_date, est_hatch, ants_removed, females_removed)) %>%
  filter(!is.na(initiation_date)) %>%
  distinct(Date,location,ants_removed,females_removed,initiation_date,est_hatch,ants_L,ants_P) %>%
  group_by(location) %>%
    mutate(b4h=Date>=initiation_date&Date<est_hatch,
           afh=Date>=est_hatch) %>%
    summarize(ants_removed=first(ants_removed),
              females_removed=first(females_removed),
              n_antsP=sum(ants_P,na.rm=T),
              ever_antsP=n_antsP>0,
              mean_antsP=mean(ants_P,na.rm=T),
              med_antsP=median(ants_P,na.rm=T),
              
              n_antsP_b4h=sum(ants_P&b4h),
              ever_antsP_b4h=n_antsP_b4h>0,
              mean_antsP_b4h=mean(ifelse(b4h,ants_P,NA),na.rm=T),
              med_antsP_b4h=median(ifelse(b4h,ants_P,NA),na.rm=T),
              
              n_antsP_afh=sum(ants_P&afh),
              ever_antsP_afh=n_antsP_afh>0,
              mean_antsP_afh=mean(ifelse(afh,ants_P,NA),na.rm=T),
              med_antsP_afh=median(ifelse(afh,ants_P,NA),na.rm=T)) %>%
  ungroup() %>%
  mutate(Dorm=substr(location,1,1),
         ant_treatment=ifelse(ants_removed,"Ants removed","Control"))

ggplot(data=ant_counts,aes(x=Dorm,y=n_antsP, fill=ant_treatment)) +
  geom_boxplot()

ggplot(data=ant_counts,aes(x=Dorm,y=mean_antsP, fill=ant_treatment)) +
  geom_boxplot()

ggplot(data=ant_counts,aes(x=Dorm,y=mean_antsP_b4h, fill=ant_treatment)) +
  geom_boxplot()

ggplot(data=ant_counts,aes(x=Dorm,y=mean_antsP_afh, fill=ant_treatment)) +
  geom_boxplot()

```

# 9.2 - Threshold for number of days ants were on the plant
Should I be more lenient with my threshold, so I can have more even sample sizes between "ants" and "no ants"?
- ants_ever = n_days_ants>0: F = 83, T = 143
- antsP_gt2d = n_days_ants>2: F = 123, T = 103 * most even sample size
- antsP_gt3d = n_days_ants>3: F = 133, T = 90
```{r}
ant_n_days <- All_data_v6 %>%
  left_join(select(visited_1st_4d_data, location, initiation_date, est_hatch, ants_removed, females_removed)) %>%
  filter(!is.na(initiation_date)) %>%
  distinct(Date,location,ants_removed,females_removed,initiation_date,est_hatch,ants_L,ants_P) %>%
  mutate(ant_treatment=ifelse(ants_removed,"Ants removed","Control"),
         Dorm=substr(location,1,1)) %>%
  group_by(Date, location) %>%
    summarize(any_antsP_day = any(ants_P>0, na.rm=T),
              females_removed = first(females_removed),
              ant_treatment = first(ant_treatment),
              Dorm = first(Dorm)) %>%
  ungroup() %>%
  group_by(location) %>%
    summarize(n_days_ants = sum(as.numeric(any_antsP_day)),
              females_removed = first(females_removed),
              ant_treatment = first(ant_treatment),
              Dorm = first(Dorm))%>%
  ungroup() %>%
  mutate(antsP_gt2d = !is.na(n_days_ants)&n_days_ants>2,
         antsP_gt3d = !is.na(n_days_ants)&n_days_ants>3,
         ants_everP = is.na(n_days_ants)|n_days_ants>0)

ant_n_days %>%
  count(females_removed, ants_everP)

ant_n_days %>%
  count(females_removed, antsP_gt2d)

ant_n_days %>%
  count(females_removed, antsP_gt3d)
```

# 10 - Estimate clutch size more robust to outliers: median top 5 egg counts

## 10.1 - Generate data for fecundity modeling

```{r}
fec_model_data <- visited_1st_4d_data_tb %>%
  filter(!is.na(guard_duration)) %>%
  group_by(location) %>%
  mutate(eggs_ever_visited = any(!mom_at_init & visit_ends <= est_hatch)) %>%
  ungroup() %>%
  select(Female_ID, location, guard_duration, est_rel2h, initiation_date, est_hatch,
         mom_at_init, clutch_initiated_order, initL, initS,
         visit_starts, visit_ends, last_day_fID,
         num_at_init, n_clutches_on_plant, `visited in 4 days`, eggs_ever_visited, ants,
         females_removed, ants_removed, 
         max_egg_num, egg_fate, egg_fate_date)
```

## 10.2 - Calculate median of top 5 egg counts in lieu of max egg counts
Taking the median (or mean) of the top 5 egg_num counts yields an estimate of max egg num that is more robust to outliers/miscounts
```{r}
tmp_t5eggs_data <- clutch_status_init_hatch_labels_v1 %>%
  mutate(est_hatch = as_date(ifelse(is.na(hatch_date),
                                 initiation_date + 20,
                                 hatch_date)),
         clutch_age = as.numeric(Date-initiation_date)) %>%
  # remove duplicate egg counts due to multiple females at a location on a day
  distinct(location, Date, initiation_date, est_hatch, clutch_age,
           egg_num, egg_len) %>%
  group_by(location) %>%
    arrange(desc(egg_num)) %>%
    mutate(top5egg_counts = rank(desc(egg_num), ties.method = "first") <= 5,
           top5egg_lens = rank(desc(egg_len), ties.method = "first") <= 5) %>%
    #filter(location == "A13_11") %>%
    select(location, Date, initiation_date, est_hatch, clutch_age,
           egg_num, egg_len, top5egg_counts, top5egg_lens) %>%
    mutate(med_t5eggs = median(ifelse(top5egg_counts,egg_num,NA), na.rm=T),
           mean_t5eggs = mean(ifelse(top5egg_counts,egg_num,NA), na.rm=T),
           max_n_eggs = max(ifelse(top5egg_counts,egg_num,NA), na.rm=T),
           med_l_t5eggs = median(ifelse(top5egg_lens,egg_len,NA), na.rm=T),
           mean_l_t5eggs = mean(ifelse(top5egg_lens,egg_len,NA), na.rm=T),
           max_l_eggs = max(ifelse(top5egg_lens,egg_len,NA), na.rm=T)) %>%
  ungroup()

top5eggs_summary <- tmp_t5eggs_data %>%
  group_by(location) %>%
    summarize(med_t5eggs = first(med_t5eggs),
              mean_t5eggs = first(mean_t5eggs),
              max_n_eggs = first(max_n_eggs),
              med_l_t5eggs = first(med_l_t5eggs),
              mean_l_t5eggs = first(mean_l_t5eggs),
              max_l_eggs = first(max_l_eggs)) %>%
  ungroup()
```


# 11 - Calculate alternative measures of maternal tenure

`The sum of all females egg-guarding durations was more predictive of final clutch size than egg guarding duration of the initiator alone (Table S1 with alternative models and their AICs), showing that females lay eggs while visiting existing clutches.`

## 11.1 - Initiator guarding time: initMb4h
```{r}
initiator_days_b4hatch <- visited_1st_4d_data_tb %>%
  filter(!is.na(initiation_date),
         # exclude clutches for which the initiators are not known
         !is.na(num_at_init),
         mom_at_init) %>%
  group_by(row_number()) %>%
  # Use median init to hatch interval (20 days) to est hatch date of clutch with no hatch date
  mutate(init_dur = ifelse(min(est_hatch, visit_ends) - 
                                       max(initiation_date, visit_starts) >= 0,
                           visit_ends-initiation_date+1, 
                           NA),
         initMb4hatch = ifelse(min(est_hatch, visit_ends) - 
                                       max(initiation_date, visit_starts) >= 0,
           min(est_hatch, visit_ends) - 
           max(initiation_date, visit_starts) + 1,
           ifelse(visit_starts > est_hatch | visit_ends < initiation_date,
                  NA,
                  NA)),
         initMb4h_sc2h = initMb4hatch/as.numeric((est_hatch-initiation_date+1))) %>%
  ungroup()

initMb4h_tbL <- initiator_days_b4hatch %>%
  filter(initL) %>%
  select(location, desert_rel2hL=est_rel2h, init_durL=init_dur, initMb4h_tbL=initMb4hatch, initMb4h_sc2hL=initMb4h_sc2h,
         females_removed, ants_removed, initiation_date, num_at_init,
         initiator_tbL=Female_ID, n_clutches_on_plant)

initMb4h_tbS <- initiator_days_b4hatch %>%
  filter(initS) %>%
  select(location, desert_rel2hS=est_rel2h, init_durS=init_dur, initMb4h_tbS=initMb4hatch, initMb4h_sc2hS=initMb4h_sc2h,
         females_removed, ants_removed, initiation_date, num_at_init,
         initiator_tbS=Female_ID, n_clutches_on_plant)
```

## 11.2 - proportional time: mDb4h
```{r}
focalMb4h_sc2h <- visited_1st_4d_data_tb  %>%
  # exclude visits to leaves that never had eggs; only interested in clutches
  filter(!is.na(initiation_date),
         # exclude clutches for which the initiators are not known (why?)
         !is.na(num_at_init)) %>%
  group_by(row_number()) %>%
  # Use median init to hatch interval (20 days) to est hatch date of clutch with no hatch date
  mutate(mD = ifelse(min(est_hatch, visit_ends) - 
                                       max(initiation_date, visit_starts) >= 0,
                     visit_ends-initiation_date+1,
                     NA),
         days_guard_b4hatch = ifelse(min(est_hatch, visit_ends) - 
                                       max(initiation_date, visit_starts) >= 0,
           min(est_hatch, visit_ends) - 
           max(initiation_date, visit_starts) + 1,
           ifelse(visit_starts > est_hatch | visit_ends < initiation_date,
                  NA,
                  NA)),
         focalMb4h_sc2h = days_guard_b4hatch/as.numeric((est_hatch-initiation_date+1))) %>%
  ungroup()

clutch_momDays_b4h <- focalMb4h_sc2h %>%
  group_by(location) %>%
    summarize(sum_mD = sum(mD, na.rm=T),
              sum_vD = sum(mD*!mom_at_init, na.rm=T),
              sum_gD = sum(mD*mom_at_init, na.rm=T),
              vDb4h_sc2h = sum(days_guard_b4hatch*!mom_at_init, na.rm = T)/
                # scale to init-hatch interval so clutches with different intervals are comparable 
                as.numeric(first(est_hatch)-first(initiation_date)+1),
              gDb4h_sc2h = sum(days_guard_b4hatch*mom_at_init, na.rm = T)/
                as.numeric((first(est_hatch)-first(initiation_date)+1)),
              mDb4h_sc2h = sum(days_guard_b4hatch, na.rm = T)/
                as.numeric((first(est_hatch)-first(initiation_date)+1))) %>%
  ungroup()

clutch_status_momDays_b4h <- visited_1st_4d_data_tb %>%
  distinct(location, initiation_date, hatch_date, num_at_init,
           females_removed, ants_removed, egg_fate, egg_fate_date,
           max_egg_num, max_egg_len, `visited in 4 days`) %>%
  right_join(clutch_momDays_b4h, by=c("location")) %>%
  left_join(top5eggs_summary)
```

## 11.3 - Latest desertion
```{r}
first_visit_cuts <- visited_1st_4d_data_tb %>%
  filter(!mom_at_init, visit_starts > initiation_date) %>%
  arrange(location, visit_starts) %>%
  group_by(location) %>%
  slice_head(n=1) %>%
  summarize(first_visit_starts = ifelse(num_at_init > 1, 0, as.numeric(visit_starts-initiation_date))) %>%
  mutate(first_visit_cut = cut(first_visit_starts, breaks=seq(0,40,4)))

moms_plant_data <- visited_1st_4d_data %>%
  filter(!is.na(initiation_date)) %>%
  separate(location, "_", into=c("DormPlant","Leaf")) %>%
  group_by(DormPlant) %>%
  summarize(n_moms_alltime = n(),
            n_moms_leaf_H = sum(est_rel2h>=0, na.rm=T),
            any_moms_leaf_H = any(est_rel2h>=0, na.rm=T),
            last_visit_ends_P = max(visit_ends, na.rm=T),
            n_moms_P_H = sum((last_visit_ends_P-est_hatch)>=0, na.rm=T),
            any_moms_P_H = any((last_visit_ends_P-est_hatch)>=0, na.rm=T),
            n_moms_P_8afterH = sum((last_visit_ends_P-est_hatch+8)>=0, na.rm=T),
            any_moms_P_8afterH = sum((last_visit_ends_P-est_hatch+8)>=0, na.rm=T),
            n_clutches_on_plant = first(n_clutches_on_plant)) %>%
  ungroup()

latest_desertions <- visited_1st_4d_data %>%
  filter(!is.na(initiation_date),
         !(visit_ends<initiation_date), # visits that end before initiation are irrelevant
         !(visit_starts>est_hatch+4)) %>% # there are a few cases where clutches are visited long after hatching, which wouldn't affect hatching success
  left_join(first_visit_cuts) %>%
  select(Female_ID:visit_ends, initiation_date, est_hatch, est_rel2h, 
         `visited in 4 days`, mom_at_init, ants_removed, females_removed) %>%
  group_by(location) %>%
  filter(any(mom_at_init)) %>% # remove any clutches where there was no apparent mother at initiation
  summarize(last_des_rel2h = max(ifelse(visit_starts<=initiation_date, est_rel2h, NA), na.rm=T),
            first_des_rel2h_init = min(ifelse(mom_at_init, est_rel2h, NA), na.rm=T),
            last_desert = ifelse(last_des_rel2h>=-2, "after hatch",
                                 ifelse(last_des_rel2h<=0, "before hatch", NA)),
            females_removed = first(females_removed),
            ants_removed = first(ants_removed),
            `visited in 4 days` = first(`visited in 4 days`),
            init_desert_early = ifelse(first(first_des_rel2h_init<=-16), "deserted early", "didn't desert early"),
            est_hatch = first(est_hatch)) %>%
  ungroup() #%>%
  # filter(!is.na(`visited in 4 days`)) %>% # E40_9 for some reason didn't get a valid visited in 4 days entry
  # filter(location!="A23_8") %>% # A23_8 has two moms at init but for some reason not `visited in 4 days`?
```

## 11.4 - Combined table of guarding tenures and offspring counts
```{r}
#### combine the three (but after getting more comfortable with the "latest_desertions" results I can omit the initL/S for simplicity)
clutch_egg_num_data <- latest_desertions %>%
  left_join(initMb4h_tbL) %>%
  left_join(initMb4h_tbS) %>%
  separate(location, sep = "_", into = c("DormPlant"),  remove = FALSE, extra = "drop") %>%
  left_join(select(clutch_status_momDays_b4h, location, sum_mD, sum_vD, sum_gD,
                   mDb4h_sc2h, gDb4h_sc2h, vDb4h_sc2h, max_egg_num, max_egg_len,
                   `visited in 4 days`)) %>%
  # if tbL and tbS are not the same female, add the female that lost the tie-break to the total sum of visit days
  mutate(sum_vD_initL = ifelse(initiator_tbL!=initiator_tbS,
                           sum_vD+init_durS, sum_vD),
         sum_vD_initS = ifelse(initiator_tbS!=initiator_tbL,
                           sum_vD+init_durL, sum_vD),
         visited = vDb4h_sc2h > 0,
         pmDvD = vDb4h_sc2h/mDb4h_sc2h) %>%
  left_join(top5eggs_summary) %>%
  select(location, last_des_rel2h, first_des_rel2h_init,
         ants_removed, females_removed, initiation_date, est_hatch, `visited in 4 days`,
         sum_mD, sum_vD, sum_gD, mDb4h_sc2h,
         num_at_init, init_desert_early, last_desert,
         n_eggs = max_egg_num, med_t5eggs, mean_t5eggs, max_n_eggs,
         max_egg_len, med_l_t5eggs, mean_l_t5eggs, max_l_eggs,
         init_durL, init_durS, desert_rel2hL, desert_rel2hS,
         sum_vD_initL, sum_vD_initS, initMb4h_sc2hL, initMb4h_sc2hS,
         initiator_tbL, initiator_tbS,
         n_clutches_on_plant, visited, pmDvD, DormPlant)

# add filtered and curated nymph and adult counts
clutch_survivorship_data <- clutch_egg_num_data %>%
  left_join(select(clutch_unambig_NOr_revised_ENAa_summary_imfilt_success_summary_v2,
                   -c(ants_removed, females_removed, initiation_date, n_eggs)),
            by=c("location"="NOr_rev_loc"))
```


# 12 - Write data for `Publilia-03-survivorship.Rmd` to `.rds` for further analysis in clean environment

## 12.0 - Combine all data for regressions
```{r}
surv_reg_data <- clutch_survivorship_data %>% 
  filter(!is.na(`visited in 4 days`)) %>%
  select(location, med_t5eggs, n_hatched, n_survived,
         des=last_des_rel2h, ants_removed, vis=`visited in 4 days`,
         females_removed, initiation_date, est_hatch) %>%
  mutate(n_survived = ifelse(n_survived/n_hatched > 1,# if n_survived/n_hatched>1
                             n_hatched, n_survived), # force n_survived/n_hatched=1
         ant_treatment=ifelse(ants_removed, "Removed", "Control")) %>%
  left_join(select(ant_counts, location, 
                   ever_antsP_b4h, ever_antsP_afh, ever_antsP)) %>%
  mutate(ants_b4h=ifelse(ever_antsP_b4h," ever", " never"),
         ants_afh=ifelse(ever_antsP_afh," ever"," never"),
         ants_ever=ifelse(ever_antsP," ever"," never")) %>%
  left_join(select(ant_n_days, -ants_everP, -ant_treatment, -females_removed)) %>%
  mutate(ants_gt2d=ifelse(antsP_gt2d," ants", " no ants"),
         ants_gt3d=ifelse(antsP_gt3d," ants", " no ants")) %>% 
  separate(location, into = c("DormPlant", "Leaf"), sep="_", remove=FALSE) %>%
  left_join(dplyr::select(moms_plant_data, DormPlant, last_visit_ends_P), by="DormPlant") %>%
  mutate(last_desP_rel2h = last_visit_ends_P-est_hatch,
         desP = last_desP_rel2h) 
```

## `Publilia-03-survivorship.Rmd`
```{r}
write_rds(surv_reg_data, here("saved_rds/surv_reg_data.rds"))
```

